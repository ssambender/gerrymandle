<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Gerrymandle</title>
  <link rel="icon" href="https://raw.githubusercontent.com/ssambender/gerrymandle/refs/heads/main/g-logo.png">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Zain:ital,wght@0,200;0,300;0,400;0,700;0,800;0,900;1,300;1,400&display=swap" rel="stylesheet">
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Zain:ital,wght@0,200;0,300;0,400;0,700;0,800;0,900;1,300;1,400&display=swap');

    :root {
      --bg: #ffffff;
      --bg-opacity: rgba(255, 255, 255, 0.75);
      --text: #55698c;

      --gray-highlight: #E8E8E8;
      --red-highlight: #eeb5ae;
      --blue-highlight: #aed1ee;
      --purple-highlight: #ddc6ea;

      --gray-letter: #dadada;
      --red-letter: #e05353;
      --blue-letter: #5988d1;
    }
    /* Override light theme manually */
    html[data-theme="light"] {
      --bg: #ffffff;
      --bg-opacity: rgba(255, 255, 255, 0.75);
      --text: #55698c;
      --gray-highlight: #E8E8E8;
      --red-highlight: #eeb5ae;
      --blue-highlight: #aed1ee;
      --purple-highlight: #ddc6ea;
      --gray-letter: #dadada;
      --red-letter: #e05353;
      --blue-letter: #5988d1;
    }

    /* Override dark theme manually */
    html[data-theme="dark"] {
      --bg: #242f3b;
      --bg-opacity: rgba(36, 47, 59, 0.75);
      --text: #ffffff;
      --gray-highlight: #424f5e;
      --red-highlight: #803026;
      --blue-highlight: #164c7d;
      --purple-highlight: #5f436f;
      --gray-letter: #6e7a86;
      --red-letter: #e05353;
      --blue-letter: #5988d1;
    }

    /* Fallback for system preference (only used if no manual override) */
    @media (prefers-color-scheme: dark) {
      html:not([data-theme]) {
        --bg: #242f3b;
        --bg-opacity: rgba(36, 47, 59, 0.75);
        --text: #ffffff;
        --gray-highlight: #424f5e;
        --red-highlight: #803026;
        --blue-highlight: #164c7d;
        --purple-highlight: #5f436f;
        --gray-letter: #6e7a86;
        --red-letter: #e05353;
        --blue-letter: #5988d1;
      }
    }

    body {
      font-family: 'Zain', 'Clear Sans', 'Helvetica Neue', 'Franklin Gothic Demi Cond', 'Bahnschrift', Arial, sans-serif;
      background: var(--bg);
      display: flex;
      flex-direction: column;
      /*justify-content: center;*/
      align-items: center;
      margin: 0;
      min-height: 100vh;
    }
    @media (min-width: 1060px) {
      body {
        max-height: 100vh;
      }
    }

    button {
      font-family: 'Zain', 'Clear Sans', 'Helvetica Neue', 'Franklin Gothic Demi Cond', 'Bahnschrift', Arial, sans-serif;
      padding-top: 4px;
    }

    #heading {
      color: var(--text);
      font-weight: normal;
      text-transform: uppercase;
      margin-bottom: 0;
      border-bottom: 1px solid var(--gray-highlight);
      width: 100%;
      text-align: center;

      z-index: 20;

      margin-top: 0;
      display: flex;
      justify-content: center;
      align-items: center;
      line-height: 1;
      padding: 14px 0 8px;
    }

    #help-button {
      position: absolute;
      right: 48px;
      cursor: pointer;
      user-select: none;
      visibility: hidden;
      pointer-events: none;
    }

    #theme-select {
      color: var(--text);
      font-weight: bold;
      background: var(--bg);
      outline: none;
      border: solid 2px var(--gray-highlight);
    }

    .popup-modal-container {
      position: absolute;
      width: 100vw;
      height: 100vh;
      background-color: var(--bg-opacity);
      z-index: 10;
      display: flex;
      justify-content: center;
      align-items: center;
      color: var(--text);
      text-align: center;
      transition: opacity 1s;
    }
    #start-modal-container.popup-modal-container {
      background-color: var(--bg);
    }
    .popup-modal {
      background-color: var(--bg);
      padding: 48px;
      /*border-radius: 36px;*/
      border: solid 2px var(--gray-highlight);
      color: var(--text);
      cursor: default;
      position: relative;
    }

    #share-line {
      text-decoration: underline;
      color: var(--blue-highlight);
      transition: color .15s;
    }
    #share-line:hover {
      cursor: pointer;
      color: var(--blue-letter);
    }
    .modal-close {
      position: absolute;
      top: 12px;
      right: 24px;
      transform: rotate(45deg);
      font-weight: 100;
      font-size: 2em;
      cursor: pointer;
      color: var(--red-highlight);
      transition: color .15s;
    }
    .modal-close:hover {
      color: var(--red-letter);
    }

    #start-modal {
      max-width: 30vw;
      padding: 48px 48px 24px 48px;
    }

    #start-game-button {
      background: none;
      outline: none;
      color: var(--gray-highlight);
      border: solid 2px var(--gray-highlight);
      transition: color .15s, border .15s;
      cursor: pointer;
      font-size: 1.5em;
      padding: 12px 24px 8px;
      border-radius: 8px;
      margin-top: 24px;
    }
    #start-game-button:hover {
      color: var(--gray-letter);
      border: solid 2px var(--gray-letter);
    }

    @media all and (orientation: portrait) {
      #heading {
        font-size: 1.5em;
      }
      #puzzle-info {
        font-size: 1.25em;
      }
      #start-modal {
        max-width: 50%;
      }
      #start-modal-container {
        z-index: 24;
      }
      #help-button {
        right: 24px;
      }
    }

    #board-container {
      position: relative;
      width: 460px;
      height: 620px;
      min-height: 620px;
    }

    #board {
      display: grid;
      grid-template-columns: repeat(6, 60px);
      grid-template-rows: repeat(8, 60px);
      gap: 20px;
      position: absolute;
      z-index: 2;
    }

    .tile {
      width: 60px;
      height: 60px;
      border-radius: 50%;
      background: var(--bg);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 28px;
      font-weight: bold;
      color: var(--text);
      /*cursor: pointer;*/
      user-select: none;
      line-height: 1;  /* remove this line if using text not symbols in tiles */
      vertical-align: middle;
    }

    /* Highlight classes */
    .tile.selected {
      background: var(--gray-highlight);
    }
    .tile.selected-red {
      background: var(--red-highlight);
    }
    .tile.selected-blue {
      background: var(--blue-highlight);
    }
    .tile.selected-purple {
      background: var(--purple-highlight);
    }

    .tile-red {
      color: var(--red-letter);
    }
    .tile-blue {
      color: var(--blue-letter);
    }
    .tile-gray {
      color: var(--gray-letter);
    }

    #line-canvas {
      position: absolute;
      top: 0;
      left: 0;
      z-index: 1;
      pointer-events: none;
    }

    #level-buttons {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      margin-top: 12px;
      padding: 10px;
      justify-content: center;
      align-items: center;
    }
    #level-buttons button {
      background: var(--bg);
      outline: none;
      border: solid 2px var(--gray-highlight);
      color: var(--gray-highlight);
      cursor: pointer;
    }
    #level-buttons button:hover {
      color: var(--text);
      border: solid 2px var(--text);
    }

    #madebysam {
      color: var(--text);
      cursor: pointer;
      margin-top: 36px;
      padding-bottom: 12px;
      text-align: center;
      font-size: 0.9rem;
      text-decoration: none;
    }
    #madebysam:hover {
      text-decoration: underline;
    }

    @keyframes pop {
      0%   { transform: scale(1); }
      30%  { transform: scale(1.1); }
      60%  { transform: scale(0.95); }
      100% { transform: scale(1); }
    }

    .tile.pop {
      animation: pop 250ms ease-out;
    }
    .tile.fade-text {
      transition: color 1s ease;
      color: transparent !important;
    }

    .district-segment {
      height: 100%;
      transition: width 0.3s ease;
    }

    @media (max-width: 619px) {
      body {
        overflow-y: hidden;
      }
      #board-container {
        width: 360px;
        height: 484px;
        min-height: 484px;
      }

      #board {
        grid-template-columns: repeat(6, 40px);
        grid-template-rows: repeat(8, 40px);
        gap: 14px;
      }

      .tile {
        width: 40px;
        height: 40px;
        font-size: 20px;
      }

      #line-canvas {
        width: 360px !important;
        height: 484px !important;
      }

      #start-modal-container {
        height: 100%;
      }
      #start-modal {
        max-width: 90%;
        padding: 8px;
      }
    }

    @media (max-width: 460px) {
      #heading {
        font-size: 1.1em;
        box-sizing: border-box;
      }
      #help-button {
        right: 12px;
      }
    }
  </style>
</head>
<body>

<div id="start-modal-container" class="popup-modal-container" style="display: flex;">
  <div id="start-modal" class="popup-modal" style="text-align: left;">
    <div id="start-close" class="modal-close" style="display: none;">+</div>
    <div style="font-weight: bold; font-size: 1.5em;">How to Play :</div>
    <div style="font-weight: normal;">
      • Draw districts by dragging/connecting adjacent star tiles<br>
      • Each district must include exactly <b id="number-voters-today">#</b> stars<br>
      • Majority of star colors in a district win that color the district<br>
      • You win by totalling more Red districts than Blue<br>
      • Click on a district to remove it and try again<br>
    </div>
    <br>
    <div style="font-weight: bold; font-size: 1.5em;">What is Gerrymandering?</div>
    <div style="font-weight: normal;">Gerrymandering is when politicians redraw voting district boundaries to unfairly boost their own party’s power,
      often silencing the voices of larger communities. It flips democracy on its head—letting leaders choose their voters
      instead of voters choosing their leaders. In the end, the will of the majority is replaced by the agenda of the minority.
    </div>
    <br>
    <div id="theme-toggle" style="z-index: 25;">
      <label for="theme-select" style="color: var(--text);">Theme:</label>
      <select id="theme-select">
        <option value="system">System</option>
        <option value="light">Light</option>
        <option value="dark">Dark</option>
      </select>
    </div>
    <br>
    <i>( You can reopen this screen at any time with the <span style="font-weight: 900">?</span> at the top right )</i>

    <div style="display: flex; justify-content: center;">
      <button id="start-game-button">BEGIN</button>
    </div>
  </div>
</div>

<div id="finish-modal-container" class="popup-modal-container" style="display: none; z-index: 21">
  <div id="finish-modal" class="popup-modal">
    <div id="finish-close" class="modal-close">+</div>
    <div id="win-message" style="font-weight: bold; font-size: 1.5em; text-transform: uppercase;">Well Done!</div>
    <div style="font-weight: normal; font-size: 1em; margin: 16px 0; color: var(--text);">FINISHED MAP #<span id="map-number-label">0</span> IN <span id="time-spent-label">02:12s</span></div>
    <div id="share-line">Share your time with friends.</div>
  </div>
</div>

<h1 id="heading">
  <div><span style="color: var(--red-letter)">★★★</span> Gerrymandle <span style="color: var(--blue-letter)">★★★</span></div>
  <div id="help-button">?</div>
</h1>

<h2 id="puzzle-info" style="margin-bottom: 0; color: var(--text);">? districts of ?</h2>
<h3 id="puzzle-subinfo" style="margin-top: 0; margin-bottom: 0; font-weight: normal; color: var(--text);"><b style="color: var(--blue-letter)">17</b> - <b style="color: var(--red-letter)">13</b>. Help red win!</h3>
<div id="puzzle-districtbar" style="margin-top: 10px; width: 260px; height: 20px; background: var(--gray-highlight); display: flex; border-radius: 10px; overflow: hidden; margin-bottom: 10px;"></div>
<div id="board-container">
  <canvas id="line-canvas" width="460" height="620"></canvas>
  <div id="board"></div>
</div>

<div id="level-buttons"></div>

<a id="madebysam" href="https://sambender.net">
  Made with ❤️ by Sam Bender
</a>

<script>
  // get day number (days since aug 1 2025)
  const startDate = new Date("2025-08-01T00:00:00");
  const today = new Date();
  const diffTime = today - startDate;
  let dayOfMap = Math.floor(diffTime / (1000 * 60 * 60 * 24));
  document.getElementById('map-number-label').innerText = dayOfMap;

  // board params
  const boardCols = 6;
  const boardRows = 8;

  const levels = {
    LVL00: ["16", "3",
      "B", "B", "B", "B", "B", "B",
      "R", "R", "B", "R", "R", "B",
      "R", "R", "B", "R", "R", "B",
      "B", "B", "B", "B", "B", "B",
      "R", "R", "B", "R", "R", "B",
      "R", "R", "B", "R", "R", "B",
      "R", "R", "B", "R", "R", "B",
      "B", "B", "B", "B", "B", "B"
    ],
    LVL01: ["5", "3",
      " ", " ", " ", " ", " ", " ",
      " ", " ", " ", "O", "R", "R",
      "R", "B", "B", "B", "O", " ",
      " ", "B", "B", " ", "O", " ",
      " ", "R", "O", "B", " ", "B",
      " ", "R", "O", "B", " ", " ",
      " ", " ", "R", "B", "O", " ",
      " ", " ", " ", " ", " ", " "
    ],
    LVL02: ["5", "3",
      " ", " ", " ", " ", " ", " ",
      " ", " ", "B", " ", "B", "B",
      " ", "R", "R", "O", "O", " ",
      " ", "R", "B", "B", " ", " ",
      " ", "R", "R", " ", " ", " ",
      "B", "R", "B", " ", " ", " ",
      " ", "B", "B", " ", " ", " ",
      " ", " ", " ", " ", " ", " "
    ],
    LVL03: ["7", "3",
      " ", " ", " ", " ", " ", " ",
      " ", " ", "B", "B", "B", "B",
      " ", " ", "B", "B", "B", " ",
      " ", "B", "B", "R", "O", "R",
      "R", "R", "R", "B", "B", "R",
      "R", "R", "B", "O", "R", " ",
      " ", "O", "O", " ", " ", " ",
      " ", " ", " ", " ", " ", " "
    ],
    LVL04: ["5", "5",
      " ", "R", "B", "O", " ", " ",
      "R", "B", "R", "B", "O", " ",
      " ", "B", "B", "O", "B", "O",
      " ", "B", "O", "B", "O", "B",
      "B", "B", "B", "R", "B", " ",
      " ", " ", "B", "R", "R", " ",
      " ", "B", "R", "R", "O", "R",
      " ", " ", "R", "O", " ", " "
    ],
    LVL05: ["5", "3",
      " ", " ", " ", " ", " ", " ",
      " ", " ", " ", " ", " ", " ",
      "R", "R", "B", "O", " ", " ",
      " ", "B", "B", "B", "B", "R",
      "R", "O", "B", "B", "R", "B",
      "B", " ", "O", "R", " ", " ",
      " ", " ", " ", " ", " ", " ",
      " ", " ", " ", " ", " ", " "
    ],
    LVL06: ["5", "4",
      " ", " ", " ", " ", " ", " ",
      " ", "B", " ", "B", "R", " ",
      "B", " ", "O", "O", "R", "R",
      " ", "O", "B", "B", " ", "O",
      " ", "B", "R", "B", "B", "O",
      "R", "O", "R", "R", "B", "R",
      " ", " ", "B", "R", "B", " ",
      " ", " ", " ", " ", " ", " "
    ],
    LVL07: ["5", "3",
      " ", " ", " ", " ", " ", " ",
      " ", " ", " ", "O", "B", "B",
      "O", "O", "O", "B", "O", "B",
      "B", "R", "R", "B", "O", "O",
      "R", " ", "B", " ", "O", "R",
      " ", " ", " ", "B", "R", "O",
      " ", " ", " ", " ", "R", "B",
      " ", " ", " ", " ", " ", " "
    ],
    LVL08: ["3", "8",
      " ", "R", "B", "B", "B", " ",
      " ", "B", " ", " ", "R", " ",
      " ", "R", " ", " ", "B", " ",
      " ", "B", "R", "B", "B", " ",
      " ", "R", "R", "B", "B", " ",
      " ", "B", " ", " ", "R", " ",
      " ", "B", " ", " ", "R", " ",
      " ", "R", "R", "B", "R", " "
    ],
    LVL09: ["5", "5",
      " ", " ", " ", " ", "B", "B",
      " ", " ", " ", "R", "B", "O",
      "B", "R", "R", "B", "B", " ",
      " ", " ", "O", " ", "B", "R",
      "R", "B", "B", " ", "B", "B",
      " ", " ", "B", " ", "R", "R",
      " ", " ", " ", "R", "R", "B",
      " ", " ", " ", "R", "B", "B"
    ],
    LVL10: ["5", "6",
      " ", "R", " ", "B", "B", " ",
      "R", "B", "B", "R", "B", "R",
      "B", "R", "B", "B", "R", " ",
      " ", "B", "R", "B", "O", "B",
      "R", "O", "R", "B", "B", " ",
      "R", "B", "R", " ", "R", "B",
      " ", "R", "B", "B", "O", " ",
      " ", " ", " ", " ", " ", " "
    ]
  };

  const styleVars = getComputedStyle(document.documentElement);

  function generateLevelButtons() {
    const container = document.getElementById("level-buttons");
    for (const key in levels) {
      const btn = document.createElement("button");
      btn.innerText = key;
      btn.onclick = () => loadLevel(key);
      container.appendChild(btn);
    }
  }
  generateLevelButtons();

  let currentDistrictCount = 0;
  let currentVoteCount = 0;

  let levelData = [];
  let finalizedDistricts = [];

  // CHARACTER SYMBOLS TO DISPLAY
  /*
  ★✩✰
  ✪
  ✦✧
  ✯
  R 🟥
  B 🟦
  W ⬜
  */
  function getDisplayCharacter(char) {
    switch (char) {
      case "R": return "★";
      case "B": return "✪";
      case "O": return "✩";
      default: return " ";
    }
  }

  function loadLevel(levelName) {
    if (!levels[levelName]) return;

    board.style.pointerEvents = "auto";

    const data = levels[levelName];

    currentDistrictCount = parseInt(data[0]);
    currentVoteCount = parseInt(data[1]);

    // Update levelData
    levelData.length = 0;
    levelData.push(...data);

    // Clear previous state
    finalizedDistricts = [];
    board.innerHTML = "";
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // Rebuild board
    let index = 2; // skip the first two (district x vote var counts)
    for (let row = 0; row < boardRows; row++) {
      for (let col = 0; col < boardCols; col++) {
        const tile = document.createElement("div");
        tile.classList.add("tile");

        const letter = data[index] || "";
        //tile.dataset.value = letter;
        tile.dataset.value = letter; // store actual value for logic
        tile.innerText = getDisplayCharacter(letter); // show visual representation
        if (letter === "B") {
          //tile.style.color = styleVars.getPropertyValue('--blue-letter').trim();
          tile.classList.add("tile-blue");
          tile.style.cursor = "pointer";
        }
        if (letter === "R") {
          //tile.style.color = styleVars.getPropertyValue('--red-letter').trim();
          tile.classList.add("tile-red");
          tile.style.cursor = "pointer";
        }
        if (letter === "O") {
          //tile.style.color = styleVars.getPropertyValue('--gray-letter').trim();
          tile.classList.add("tile-gray");
          tile.style.cursor = "pointer";
        }

        tile.dataset.row = row;
        tile.dataset.col = col;

        tile.addEventListener("click", () => {
          if (isTileFinalized(tile)) {
            removeDistrictContainingTile(tile);
            drawLines();
          }
        });

        board.appendChild(tile);
        index++;
      }
    }

    setInfo();
    updateVoteTotals();
    updateDistrictBar();
    resizeCanvas();
  }

  const board = document.getElementById("board");
  const canvas = document.getElementById("line-canvas");
  const ctx = canvas.getContext("2d");
  let isMouseDown = false;
  let path = [];

  function resizeCanvas() {
    const container = document.getElementById("board-container");
    canvas.width = container.offsetWidth;
    canvas.height = container.offsetHeight;
    drawLines(); // redraw after resize
  }
  resizeCanvas();

  function setInfo() {
    const today = new Date();
    const mm = today.getMonth() + 1;
    const dd = today.getDate();
    const yy = String(today.getFullYear()).slice(-2);
    const formattedDate = `${mm}/${dd}/${yy}`;

    //document.getElementById('puzzle-info').innerText = `${formattedDate} - ${currentDistrictCount} districts of ${currentVoteCount}`;
    document.getElementById('puzzle-info').innerText = `${currentDistrictCount} districts of ${currentVoteCount}`;  // no date
    document.getElementById('number-voters-today').innerText = currentVoteCount;
  }
  function updateVoteTotals() {
    const rTotal = levelData.filter(cell => cell === "R").length;
    const bTotal = levelData.filter(cell => cell === "B").length;

    const subInfo = document.getElementById('puzzle-subinfo');
    subInfo.innerHTML = `<b style="color: #5988d1">${bTotal}</b> - <b style="color: #e05353">${rTotal}</b>. Help red win!`;
  }
  setInfo();
  updateVoteTotals();

  function updateDistrictBar() {
    const bar = document.getElementById("puzzle-districtbar");

    const styleVars = getComputedStyle(document.documentElement);
    const total = currentDistrictCount;
    let red = 0, blue = 0, purple = 0;

    finalizedDistricts.forEach(d => {
      if (d.colorClass === "selected-red") red++;
      else if (d.colorClass === "selected-blue") blue++;
      else if (d.colorClass === "selected-purple") purple++;
    });

    const remaining = total - red - blue - purple;

    const segments = [
      { key: "red", count: red, color: styleVars.getPropertyValue('--red-highlight').trim() },
      { key: "blue", count: blue, color: styleVars.getPropertyValue('--blue-highlight').trim() },
      { key: "purple", count: purple, color: styleVars.getPropertyValue('--purple-highlight').trim() },
      { key: "gray", count: remaining, color: styleVars.getPropertyValue('--gray-highlight').trim() }
    ];

    // Update or create segments
    segments.forEach((seg, i) => {
      let segment = bar.children[i];
      const desiredWidth = `${(seg.count / total) * 100}%`;

      if (!segment) {
        // New segment
        segment = document.createElement("div");
        segment.className = "district-segment";
        segment.style.background = seg.color;
        segment.style.width = "0";
        bar.appendChild(segment);
        requestAnimationFrame(() => {
          segment.style.width = desiredWidth;
        });
      } else {
        // Existing segment: update color & width only if changed
        if (segment.style.background !== seg.color) {
          segment.style.background = seg.color;
        }
        if (segment.style.width !== desiredWidth) {
          segment.style.width = desiredWidth;
        }
      }
    });

    // Remove extra segments if any
    while (bar.children.length > segments.length) {
      bar.removeChild(bar.lastChild);
    }
  }


  function getTileCenter(tile) {
    const rect = tile.getBoundingClientRect();
    const parentRect = board.getBoundingClientRect();
    return {
      x: rect.left - parentRect.left + rect.width / 2,
      y: rect.top - parentRect.top + rect.height / 2
    };
  }

  // Draw lines connecting tiles for given path with specified color and line width
  function drawPathLines(pathTiles, color, lineWidth = 16) {
    if (pathTiles.length < 2) return;
    ctx.strokeStyle = color;
    ctx.lineWidth = lineWidth;
    ctx.lineCap = "round";
    ctx.beginPath();
    const start = getTileCenter(pathTiles[0]);
    ctx.moveTo(start.x, start.y);
    for (let i = 1; i < pathTiles.length; i++) {
      const point = getTileCenter(pathTiles[i]);
      ctx.lineTo(point.x, point.y);
    }
    ctx.stroke();
  }

  function updateCurrentPathColors() {
    if (path.length === 0) return;

    const votes = path.map(t => t.dataset.value);
    const rCount = votes.filter(v => v === "R").length;
    const bCount = votes.filter(v => v === "B").length;

    // Remove all color classes first
    path.forEach(t => {
      t.classList.remove("selected", "selected-red", "selected-blue", "selected-purple");
    });

    const voteCount = path.filter(t => {
      const val = t.dataset.value.trim();
      return val === "R" || val === "B";
    }).length;

    if (voteCount >= currentVoteCount) {
      // Apply matching color class
      if (rCount > bCount) {
        path.forEach(t => t.classList.add("selected-red"));
      } else if (bCount > rCount) {
        path.forEach(t => t.classList.add("selected-blue"));
      } else {
        path.forEach(t => t.classList.add("selected-purple"));
      }
    } else {
      // Not full length apply default selected bg
      path.forEach(t => t.classList.add("selected"));
    }
  }

  // draws all finalized districts lines plus current drawing path line
  function drawLines() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // Draw finalized districts lines first
    finalizedDistricts.forEach(district => {
      const color = getStrokeColorForClass(district.colorClass);
      drawPathLines(district.tiles, color);
    });

    // Draw current path line if any
    if (path.length < 2) return;

    const voteCount = path.filter(t => {
      const val = t.dataset.value.trim();
      return val === "R" || val === "B";
    }).length;

    if (voteCount >= currentVoteCount) {
      const strokeColor = finalizePathColor();
      drawPathLines(path, strokeColor);
    } else {
      const gray = styleVars.getPropertyValue('--gray-highlight').trim();
      drawPathLines(path, gray);
    }

  }

  // get stroke color string for given tile class
  function getStrokeColorForClass(colorClass) {
    switch (colorClass) {
      case "selected-red": return styleVars.getPropertyValue('--red-highlight').trim();
      case "selected-blue": return styleVars.getPropertyValue('--blue-highlight').trim();
      case "selected-purple": return styleVars.getPropertyValue('--purple-highlight').trim();
      default: return styleVars.getPropertyValue('--gray-highlight').trim();
    }
  }

  function areAdjacent(tile1, tile2) {
    const r1 = +tile1.dataset.row;
    const c1 = +tile1.dataset.col;
    const r2 = +tile2.dataset.row;
    const c2 = +tile2.dataset.col;

    const rowDiff = r2 - r1;
    const colDiff = c2 - c1;

    const absRow = Math.abs(rowDiff);
    const absCol = Math.abs(colDiff);

    if (absRow > 1 || absCol > 1 || (absRow === 0 && absCol === 0)) return false;

    // Diagonal move
    if (absRow === 1 && absCol === 1) {
      const midTileA = document.querySelector(`[data-row="${r1}"][data-col="${c2}"]`);
      const midTileB = document.querySelector(`[data-row="${r2}"][data-col="${c1}"]`);

      // Check if either of the mid-tiles are connected by a finalized district
      for (const district of finalizedDistricts) {
        if (
                midTileA && midTileB &&
                district.tiles.includes(midTileA) &&
                district.tiles.includes(midTileB)
        ) {
          // They're both in a district — check if they're directly connected
          const idxA = district.tiles.indexOf(midTileA);
          const idxB = district.tiles.indexOf(midTileB);
          if (Math.abs(idxA - idxB) === 1) {
            return false; // A connector exists — block diagonal
          }
        }
      }
    }

    return true;
  }


  function clearPath() {
    path.forEach(t => {
      if (!isTileFinalized(t)) {
        t.classList.remove("selected", "selected-red", "selected-blue", "selected-purple");
      }
    });
    path = [];
    drawLines();
  }

  function isTileFinalized(tile) {
    return finalizedDistricts.some(district => district.tiles.includes(tile));
  }

  function removeDistrictContainingTile(tile) {
    for (let i = 0; i < finalizedDistricts.length; i++) {
      const district = finalizedDistricts[i];
      if (district.tiles.includes(tile)) {
        // Log what colord district is removed
        let colorName = "purple";
        if (district.colorClass === "selected-red") colorName = "red";
        else if (district.colorClass === "selected-blue") colorName = "blue";
        console.log(`${colorName} district removed`);

        district.tiles.forEach(t => {
          t.classList.remove("selected-red", "selected-blue", "selected-purple");
        });
        finalizedDistricts.splice(i, 1);

        // Log updated totals
        let redCount = 0, blueCount = 0, purpleCount = 0;
        finalizedDistricts.forEach(d => {
          if (d.colorClass === "selected-red") redCount++;
          else if (d.colorClass === "selected-blue") blueCount++;
          else if (d.colorClass === "selected-purple") purpleCount++;
        });
        console.log(`total red: ${redCount}, total blue: ${blueCount}, total purple: ${purpleCount}`);

        updateDistrictBar();

        break;
      }
    }
  }

  // SHARE DATA AND SHARE LINK
  let timeSpentSeconds = 121;
  const shareData = {
    title: 'Gerrymandle #' + dayOfMap,
    text: `🔸I beat map #${dayOfMap}` + ` in ${timeSpentSeconds}s. 🗺️ \n🔹Think you can solve it faster?\nhttps://ssambender.github.io/gerrymandle/`,
    //url: 'https://ssambender.github.io/gerrymandle/'
  }
  let sharelink = document.getElementById('share-line');
  sharelink.addEventListener('click', async () => {
    event.preventDefault();
    try {
      await navigator.share(shareData)
      console.log('shared successfully')
    } catch (err) {
      console.log('error' + err)
    }
  }, false);

  // EVENT LISTENERS
  board.addEventListener("mousedown", (e) => {
    if (!e.target.classList.contains("tile")) return;
    if (isTileFinalized(e.target)) return;
    if (e.target.dataset.value.trim() === "") return;  //prevents selecting blank spaces

    clearPath();
    isMouseDown = true;

    path.push(e.target);
    updateCurrentPathColors();
    drawLines();

    e.target.classList.add("pop");
    e.target.addEventListener("animationend", () => {
      e.target.classList.remove("pop");
    }, { once: true });
  });

  board.addEventListener("mouseover", (e) => {
    if (!isMouseDown || !e.target.classList.contains("tile")) return;
    if (isTileFinalized(e.target)) return;

    const currentTile = e.target;
    if (currentTile.dataset.value.trim() === "") return;  //prevents selecting blank spaces

    const last = path[path.length - 1];
    const secondLast = path[path.length - 2];

    // Allow retreating
    if (secondLast === currentTile) {
      const removed = path.pop();
      removed.classList.remove("selected", "selected-red", "selected-blue", "selected-purple");
      updateCurrentPathColors();
      drawLines();
      return;
    }

    const voteCount = path.filter(t => {
      const val = t.dataset.value.trim();
      return val === "R" || val === "B";
    }).length;

    const atLimit = voteCount >= currentVoteCount;

    if (atLimit) return;

    if (!path.includes(currentTile) && areAdjacent(last, currentTile)) {
      path.push(currentTile);
      updateCurrentPathColors();
      drawLines();

      currentTile.classList.add("pop");
      currentTile.addEventListener("animationend", () => {
        currentTile.classList.remove("pop");
      }, { once: true });
    }
  });

  window.addEventListener("mouseup", () => {
    if (path.length > 0) {
      const word = path.map(t => t.dataset.value).join("");
      // console.log("Selected word:", word);

      const voteCount = path.filter(t => {
        const val = t.dataset.value.trim();
        return val === "R" || val === "B";
      }).length;

      if (voteCount === currentVoteCount) {
        // Finalize district
        const colorClass = getFinalColorClass();

        finalizedDistricts.push({
          tiles: [...path],
          colorClass
        });

        // remove temp selected class and apply final color class only
        path.forEach(t => {
          t.classList.remove("selected");
          t.classList.add(colorClass);
        });

        // log district color drawn
        let colorName = "purple";
        if (colorClass === "selected-red") colorName = "red";
        else if (colorClass === "selected-blue") colorName = "blue";
        console.log(`${colorName} district drawn`);

        // Count totals
        let redCount = 0, blueCount = 0, purpleCount = 0;
        finalizedDistricts.forEach(district => {
          if (district.colorClass === "selected-red") redCount++;
          else if (district.colorClass === "selected-blue") blueCount++;
          else if (district.colorClass === "selected-purple") purpleCount++;
        });
        console.log(`total red: ${redCount}, total blue: ${blueCount}, total purple: ${purpleCount}`);

        updateDistrictBar();

        if (finalizedDistricts.length === currentDistrictCount) {
          console.log("all districts drawn");
          if (redCount > blueCount) {
            console.log("LEVEL WIN!");
            console.log("Well Done!");

            board.style.pointerEvents = "none";  // stop board edits after win
            //board.style.pointerEvents = "auto";  // to reenable events on board reset or something

            document.querySelectorAll('.tile').forEach(tile => {
              const row = parseInt(tile.dataset.row);
              const col = parseInt(tile.dataset.col);
              const delay = (row * boardCols + col) * 15;
              setTimeout(() => {
                tile.classList.add('fade-text');
              }, delay);
            });

            document.getElementById('finish-modal-container').style.display = 'flex';
            document.getElementById('finish-modal-container').style.opacity = '0';
            setTimeout(() => {
              document.getElementById('finish-modal-container').style.display = 'flex';
              document.getElementById('finish-modal-container').style.opacity = '1';
            }, 1500);
          }
          else {
            console.log("NOT QUITE! LEVEL LOSE!");
            // todo - show up "reset?" button
          }
        }

        path = [];
        drawLines();
      } else {
        clearPath();
      }
    }
    isMouseDown = false;
  });


  window.addEventListener("mouseleave", () => {
    isMouseDown = false;
  });

  function getFinalColorClass() {
    const votes = path
            .map(t => t.dataset.value)
            .filter(v => v !== "O");
    const rCount = votes.filter(v => v === "R").length;
    const bCount = votes.filter(v => v === "B").length;

    if (rCount > bCount) return "selected-red";
    else if (bCount > rCount) return "selected-blue";
    else return "selected-purple";
  }

  function finalizePathColor() {
    const votes = path
            .map(t => t.dataset.value)
            .filter(v => v !== "O");
    const rCount = votes.filter(v => v === "R").length;
    const bCount = votes.filter(v => v === "B").length;

    if (rCount > bCount) return styleVars.getPropertyValue('--red-highlight').trim();
    else if (bCount > rCount) return styleVars.getPropertyValue('--blue-highlight').trim();
    else return styleVars.getPropertyValue('--purple-highlight').trim();
  }

  window.addEventListener("resize", () => {
    resizeCanvas();
    drawLines();
  });

  window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', (e) => {
    console.log("Color scheme changed:", e.matches ? "dark" : "light");
    drawLines(); // Redraw canvas lines with updated CSS variable colors
    updateDistrictBar();
  });

  const themeSelect = document.getElementById("theme-select");

  // Load saved preference
  const savedTheme = localStorage.getItem("theme");
  if (savedTheme) {
    themeSelect.value = savedTheme;
    if (savedTheme === "system") {
      document.documentElement.removeAttribute("data-theme");

      // Manualy force updates using current system preference
      const isDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
      console.log("Using system theme:", isDark ? "dark" : "light");
    } else {
      document.documentElement.setAttribute("data-theme", savedTheme);
    }

    // Always refresh visuals on page load based on theme
    drawLines();
    updateDistrictBar();
  }

  // On theme selectchange
  themeSelect.addEventListener("change", () => {
    const theme = themeSelect.value;
    localStorage.setItem("theme", theme);
    if (theme === "system") {
      document.documentElement.removeAttribute("data-theme");
    } else {
      document.documentElement.setAttribute("data-theme", theme);
    }

    // Refresh visuals
    drawLines();
    updateDistrictBar();
  });

  // force recheck when system theme changes
  window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', () => {
    if (themeSelect.value === "system") {
      drawLines();
      updateDistrictBar();
    }
  });

  // close win modal
  document.getElementById('finish-close').addEventListener("click", () => {
    document.getElementById('finish-modal-container').style.display = 'none';
    document.getElementById('finish-modal-container').style.opacity = '0';
  });

  // close start modal
  document.getElementById('start-game-button').addEventListener("click", () => {
    document.getElementById('start-modal-container').style.display = 'none';
    document.getElementById('start-modal-container').style.opacity = '0';

    //todo - START TIMER HERE
    document.body.style.overflowY = 'visible';
    document.getElementById('start-game-button').style.display = 'none';
    document.getElementById('start-modal').style.padding = '48px';
    document.getElementById('start-close').style.display = 'flex';

    document.getElementById('help-button').style.visibility = 'visible';
    document.getElementById('help-button').style.pointerEvents = 'all';
  })

  document.getElementById('start-close').addEventListener("click", () => {
    document.getElementById('start-modal-container').style.display = 'none';
    document.getElementById('start-modal-container').style.opacity = '0';
  });

  // open help modal
  document.getElementById('help-button').addEventListener("click", () => {
    document.getElementById('start-modal-container').style.display = 'flex';
    document.getElementById('start-modal-container').style.opacity = '1';
    document.getElementById('start-modal-container').style.background = 'var(--bg-opacity)';
  });

  // start with test level loaded by default
  loadLevel('LVL01');
</script>
</body>
</html>

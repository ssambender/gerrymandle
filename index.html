<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>Gerrymandle</title>
    <style>
        body {
            font-family: sans-serif;
            background: #ffffff;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            margin: 0;
            height: 100vh;
        }

        #board-container {
            position: relative;
            width: 460px;
            height: 620px;
        }

        #board {
            display: grid;
            grid-template-columns: repeat(6, 60px);
            grid-template-rows: repeat(8, 60px);
            gap: 20px;
            position: absolute;
            z-index: 2;
        }

        .tile {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: #ffffff;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 22px;
            font-weight: bold;
            color: #333;
            cursor: pointer;
            user-select: none;
            /*transition: background-color 0.2s ease;*/
        }

        .tile.selected {
            background: #e8e8e8;
        }
        .tile.selected-red {
            background: #eeb5ae;
        }
        .tile.selected-blue {
            background: #aed1ee;
        }
        .tile.selected-purple {
            background: #ddc6ea;
        }

        #line-canvas {
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
            pointer-events: none;
        }

        @keyframes pop {
            0%   { transform: scale(1); }
            30%  { transform: scale(1.1); }  /* how big to make circle select anim */
            60%  { transform: scale(0.95); }
            100% { transform: scale(1); }
        }

        .tile.pop {
            animation: pop 250ms ease-out;  /* how fast to make circle select anim */
        }

    </style>
</head>
<body>
    <h2 id="puzzle-info">?? districts of ??</h2>

    <div id="board-container">
        <canvas id="line-canvas" width="460" height="620"></canvas>
        <div id="board"></div>
    </div>

    <script>
        const boardCols = 6;
        const boardRows = 8;

        let currentDistrictCount = 6;
        let currentVoteCount = 8;

        // Custom level data: 6 x 8 = 48 letters (row-major order)
        const levelData = [
            "R", "R", "R", "R", "R", "R",
            "R", "R", "R", "R", "R", "R",
            "B", "B", "B", "B", "B", "R",
            "B", "B", "B", "B", "B", "R",
            "B", "B", "B", "B", "B", "R",
            "B", "B", "B", "B", "B", "R",
            "B", "B", "B", "B", "B", "R",
            "B", "B", "B", "B", "B", "R"
        ];

        const board = document.getElementById("board");
        const canvas = document.getElementById("line-canvas");
        const ctx = canvas.getContext("2d");
        let isMouseDown = false;
        let path = [];

        function setInfo() {
            document.getElementById('puzzle-info').innerText = `${currentDistrictCount} districts of ${currentVoteCount}`;
        }

        // use in future instead of hardcoding levelData
        function loadMap() {
            console.log("load map")
        }

        setInfo();

        function getTileCenter(tile) {
            const rect = tile.getBoundingClientRect();
            const parentRect = board.getBoundingClientRect();
            return {
                x: rect.left - parentRect.left + rect.width / 2,
                y: rect.top - parentRect.top + rect.height / 2
            };
        }

        function drawLines() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            if (path.length < 2) return;

            const currentWord = path.map(t => t.textContent).join("").replace(/ /g, "");

            let strokeColor = "#e8e8e8"; // default gray

            if (currentWord.length >= currentVoteCount) {
                strokeColor = finalizePathColor();  // apply final result
            } else {
                clearPathColoring();  // remove any result-based styles
            }

            ctx.strokeStyle = strokeColor;
            ctx.lineWidth = 16;
            ctx.beginPath();
            const start = getTileCenter(path[0]);
            ctx.moveTo(start.x, start.y);
            for (let i = 1; i < path.length; i++) {
                const point = getTileCenter(path[i]);
                ctx.lineTo(point.x, point.y);
            }
            ctx.stroke();
        }


        function areAdjacent(tile1, tile2) {
            const r1 = +tile1.dataset.row;
            const c1 = +tile1.dataset.col;
            const r2 = +tile2.dataset.row;
            const c2 = +tile2.dataset.col;
            return Math.abs(r1 - r2) <= 1 && Math.abs(c1 - c2) <= 1;
        }

        function clearPath() {
            path.forEach(t => {
                t.classList.remove("selected", "selected-red", "selected-blue", "selected-purple");
            });
            path = [];
            drawLines();
        }

        function clearPathColoring() {
            path.forEach(t => {
                t.classList.remove("selected-red", "selected-blue", "selected-purple");
            });
        }

        // Generate board from levelData
        let index = 0;
        for (let row = 0; row < boardRows; row++) {
            for (let col = 0; col < boardCols; col++) {
                const tile = document.createElement("div");
                tile.classList.add("tile");

                const letter = levelData[index] || "";
                tile.textContent = letter;
                //tile.textContent = levelData[index] || ""; // || what the space is when left blank
                if (letter === "B") tile.style.color = "#5988d1";
                if (letter === "R") tile.style.color = "#e05353";

                tile.dataset.row = row;
                tile.dataset.col = col;
                board.appendChild(tile);
                index++;
            }
        }

        board.addEventListener("mousedown", (e) => {
            if (!e.target.classList.contains("tile")) return;
            clearPath();
            isMouseDown = true;
            e.target.classList.add("selected", "pop");
            e.target.classList.add("selected");
            path.push(e.target);
            drawLines();

            e.target.addEventListener("animationend", () => {
                e.target.classList.remove("pop");
            }, { once: true });
        });

        board.addEventListener("mouseover", (e) => {
            if (!isMouseDown || !e.target.classList.contains("tile")) return;

            const currentTile = e.target;
            const last = path[path.length - 1];
            const secondLast = path[path.length - 2];

            // Allow retreating
            if (secondLast === currentTile) {
                const removed = path.pop();
                removed.classList.remove("selected", "selected-red", "selected-blue", "selected-purple");
                drawLines();
                return;
            }

            // Count non-space tiles only
            const currentWord = path.map(t => t.textContent).join("").replace(/ /g, "");
            const atLimit = currentWord.length >= currentVoteCount;

            // if current connection at limit don't allow add more but still allow retreating
            if (atLimit) return;

            // Allow forawrd if adjacent and not already in path
            if (!path.includes(currentTile) && areAdjacent(last, currentTile)) {
                currentTile.classList.add("selected", "pop");
                path.push(currentTile);
                drawLines();

                currentTile.addEventListener("animationend", () => {
                    currentTile.classList.remove("pop");
                }, { once: true });
            }
        });

        window.addEventListener("mouseup", () => {
            if (path.length > 0) {
                const word = path.map(t => t.textContent).join("");
                console.log("Selected word:", word);
                console.log(word.replace(/ /g,'').length);
            }
            isMouseDown = false;
        });

        window.addEventListener("mouseleave", () => {
            isMouseDown = false;
        });

        function finalizePathColor() {
            const votes = path.map(t => t.textContent);
            const rCount = votes.filter(v => v === "R").length;
            const bCount = votes.filter(v => v === "B").length;

            let color = "#e8e8e8"; // default gray

            // Remove prior result-based selection classes
            path.forEach(t => {
                t.classList.remove("selected-red", "selected-blue", "selected-purple");
            });

            if (rCount > bCount) {
                color = "#eeb5ae";
                path.forEach(t => t.classList.add("selected-red"));
            } else if (bCount > rCount) {
                color = "#aed1ee";
                path.forEach(t => t.classList.add("selected-blue"));
            } else {
                color = "#ddc6ea";
                path.forEach(t => t.classList.add("selected-purple"));
            }

            return color;
        }

        window.addEventListener("resize", drawLines);
    </script>
</body>
</html>

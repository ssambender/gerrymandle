<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Gerrymandle</title>
  <link rel="icon" href="https://raw.githubusercontent.com/ssambender/gerrymandle/refs/heads/main/g-logo.png">
  <link rel="apple-touch-icon" href="https://raw.githubusercontent.com/ssambender/gerrymandle/refs/heads/main/g-logo.png">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Zain:ital,wght@0,200;0,300;0,400;0,700;0,800;0,900;1,300;1,400&display=swap" rel="stylesheet">
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Zain:ital,wght@0,200;0,300;0,400;0,700;0,800;0,900;1,300;1,400&display=swap');

    :root {
      --bg: #ffffff;
      --bg-opacity: rgba(255, 255, 255, 0.75);
      --text: #55698c;

      --gray-highlight: #E8E8E8;
      --red-highlight: #eeb5ae;
      --blue-highlight: #aed1ee;
      --purple-highlight: #ddc6ea;

      --gray-letter: #dadada;
      --red-letter: #e05353;
      --blue-letter: #5988d1;
    }
    /* Override light theme manually */
    html[data-theme="light"] {
      --bg: #ffffff;
      --bg-opacity: rgba(255, 255, 255, 0.75);
      --text: #55698c;
      --gray-highlight: #E8E8E8;
      --red-highlight: #eeb5ae;
      --blue-highlight: #aed1ee;
      --purple-highlight: #ddc6ea;
      --gray-letter: #dadada;
      --red-letter: #e05353;
      --blue-letter: #5988d1;
    }

    /* Override dark theme manually */
    html[data-theme="dark"] {
      --bg: #242f3b;
      --bg-opacity: rgba(36, 47, 59, 0.75);
      --text: #ffffff;
      --gray-highlight: #424f5e;
      --red-highlight: #803026;
      --blue-highlight: #164c7d;
      --purple-highlight: #5f436f;
      --gray-letter: #6e7a86;
      --red-letter: #e05353;
      --blue-letter: #5988d1;
    }

    /* Fallback for system preference (only used if no manual override) */
    @media (prefers-color-scheme: dark) {
      html:not([data-theme]) {
        --bg: #242f3b;
        --bg-opacity: rgba(36, 47, 59, 0.75);
        --text: #ffffff;
        --gray-highlight: #424f5e;
        --red-highlight: #803026;
        --blue-highlight: #164c7d;
        --purple-highlight: #5f436f;
        --gray-letter: #6e7a86;
        --red-letter: #e05353;
        --blue-letter: #5988d1;
      }
    }

    body {
      font-family: 'Zain', 'Clear Sans', 'Helvetica Neue', 'Franklin Gothic Demi Cond', 'Bahnschrift', Arial, sans-serif;
      background: var(--bg);
      display: flex;
      flex-direction: column;
      /*justify-content: center;*/
      align-items: center;
      margin: 0;
      min-height: 100vh;
    }
    @media (min-width: 1060px) {
      body {
        max-height: 100vh;
      }
    }

    button {
      font-family: 'Zain', 'Clear Sans', 'Helvetica Neue', 'Franklin Gothic Demi Cond', 'Bahnschrift', Arial, sans-serif;
      padding-top: 4px;
    }

    #heading {
      color: var(--text);
      font-weight: normal;
      text-transform: uppercase;
      margin-bottom: 0;
      border-bottom: 1px solid var(--gray-highlight);
      width: 100%;
      text-align: center;

      z-index: 20;

      margin-top: 0;
      display: flex;
      justify-content: center;
      align-items: center;
      line-height: 1;
      padding: 14px 0 8px;
    }

    #help-button {
      position: absolute;
      right: 48px;
      cursor: pointer;
      user-select: none;
      visibility: hidden;
      pointer-events: none;
      font-weight: 800;
    }

    #theme-select, #team-select {
      color: var(--text);
      font-weight: bold;
      background: var(--bg);
      outline: none;
      border: solid 2px var(--gray-highlight);
    }
    #theme-select:disabled, #team-select:disabled {
      pointer-events: none;
      opacity: 0.5;
      user-select: none;
    }

    .popup-modal-container {
      position: absolute;
      width: 100vw;
      height: 100vh;
      background-color: var(--bg-opacity);
      z-index: 10;
      display: flex;
      justify-content: center;
      align-items: center;
      color: var(--text);
      text-align: center;
      transition: opacity 1s;
    }
    #start-modal-container.popup-modal-container {
      background-color: var(--bg);
    }
    .popup-modal {
      background-color: var(--bg);
      padding: 48px;
      /*border-radius: 36px;*/
      border: solid 2px var(--gray-highlight);
      color: var(--text);
      cursor: default;
      position: relative;
    }

    #share-line {
      text-decoration: underline;
      color: var(--blue-highlight);
      transition: color .15s;
    }
    #share-line:hover {
      cursor: pointer;
      color: var(--blue-letter);
    }
    .modal-close {
      position: absolute;
      top: 12px;
      right: 24px;
      transform: rotate(45deg);
      font-weight: 700;
      font-size: 2em;
      cursor: pointer;
      color: var(--red-highlight);
      transition: color .15s;
    }
    .modal-close:hover {
      color: var(--red-letter);
    }

    #leveleditor-line {
      text-decoration: underline;
      color: var(--blue-highlight);
      transition: color .15s;
    }
    #leveleditor-line:hover {
      cursor: pointer;
      color: var(--blue-letter);
    }

    #start-modal {
      max-width: 30vw;
      padding: 48px 48px 24px 48px;
    }

    #start-game-button {
      background: none;
      outline: none;
      color: var(--gray-letter);
      border: solid 2px var(--gray-highlight);
      /*transition: color .15s, border .15s;*/
      cursor: pointer;
      font-size: 1.5em;
      padding: 12px 24px 8px;
      border-radius: 8px;
      margin-top: 24px;
    }
    #start-game-button:hover {
      color: var(--text);
      border: solid 2px var(--text);
    }

    @media all and (orientation: portrait) {
      #heading {
        font-size: 1.5em;
      }
      #puzzle-info {
        font-size: 1.25em;
      }
      #start-modal {
        max-width: 50%;
      }
      #start-modal-container {
        z-index: 24;
      }
      #help-button {
        right: 24px;
      }

      .popup-modal {
        position: absolute;
        top: 0;
      }
      #finish-modal {
        position: relative;
      }
    }

    #board-container {
      position: relative;
      width: 460px;
      height: 620px;
      min-height: 620px;

      /* center board within container on mobile */
      display: flex;
      justify-content: center;
      align-items: center;
    }

    #board {
      display: grid;
      grid-template-columns: repeat(6, 60px);
      grid-template-rows: repeat(8, 60px);
      gap: 20px;
      position: absolute;
      z-index: 2;

      /* stop accidental scroll on mobile */
      touch-action: none;
    }

    .tile {
      width: 60px;
      height: 60px;
      border-radius: 50%;
      background: var(--bg);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 28px;
      font-weight: bold;
      color: var(--text);
      /*cursor: pointer;*/
      user-select: none;
      /*line-height: 1;*/
      /*vertical-align: middle;*/
    }

    /* Highlight classes */
    .tile.selected {
      background: var(--gray-highlight);
    }
    .tile.selected-red {
      background: var(--red-highlight);
    }
    .tile.selected-blue {
      background: var(--blue-highlight);
    }
    .tile.selected-purple {
      background: var(--purple-highlight);
    }

    .tile-red {
      color: var(--red-letter);
    }
    .tile-blue {
      color: var(--blue-letter);
    }
    .tile-gray {
      color: var(--gray-letter);
    }

    #line-canvas {
      position: absolute;
      top: 0;
      left: 0;
      z-index: 1;
      pointer-events: none;
    }

    #timelabel {
      color: var(--text);
    }

    #level-buttons {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      margin-top: 12px;
      justify-content: center;
      align-items: center;
    }
    #level-buttons button {
      background: var(--bg);
      outline: none;
      border: solid 2px var(--gray-highlight);
      color: var(--gray-letter);
      cursor: pointer;
    }
    #level-buttons button:hover {
      color: var(--text);
      border: solid 2px var(--text);
    }

    #madebysam {
      color: var(--text);
      cursor: pointer;
      margin-top: 36px;
      padding-bottom: 12px;
      text-align: center;
      font-size: 0.9rem;
      text-decoration: none;
      font-weight: bold;
    }
    #madebysam:hover {
      text-decoration: underline;
    }

    @keyframes pop {
      0%   { transform: scale(1); }
      30%  { transform: scale(1.1); }
      60%  { transform: scale(0.95); }
      100% { transform: scale(1); }
    }

    .tile.pop {
      animation: pop 250ms ease-out;
    }
    .tile.fade-text {
      transition: color 1s ease;
      color: transparent !important;
    }

    .district-segment {
      height: 100%;
      transition: width 0.3s ease;
    }

    @media (max-width: 619px) {
      #board-container {
        width: 360px;
        height: 484px;
        min-height: 484px;
      }

      #board {
        grid-template-columns: repeat(6, 40px);
        grid-template-rows: repeat(8, 40px);
        gap: 14px;
      }

      .tile {
        width: 40px;
        height: 40px;
        font-size: 20px;
      }

      #line-canvas {
        position: absolute;
        top: 33px;
        left: 25px;
      }

      #start-modal-container {
        height: 100%;
      }
      #start-modal {
        max-width: 90%;
        padding: 8px;
      }
    }

    @media (max-width: 460px) {
      #heading {
        font-size: 1.1em;
        box-sizing: border-box;
      }
      #help-button {
        right: 12px;
      }
    }
  </style>
</head>
<body>

<div id="start-modal-container" class="popup-modal-container" style="display: flex;">
  <div id="start-modal" class="popup-modal" style="text-align: left;">
    <div id="start-close" class="modal-close" style="display: none;">+</div>
    <div style="font-weight: bold; font-size: 1.5em;">How to Play :</div>
    <div style="font-weight: normal;">
      ‚Ä¢ Select a party color below - you're trying to rig the map in their favor<br>
      ‚Ä¢ Create voting districts by dragging to connect <b>adjacent</b> star tiles<br>
      ‚Ä¢ You can connect in any direction, but districts can't overlap or cross<br>
      ‚Ä¢ Use gray tiles to bridge gaps - they help connect stars but don‚Äôt count towards the district's total<br>
      ‚Ä¢ Each district must contain exactly the same number of stars (excluding gray)<br> <!-- (<b id="number-voters-today">#</b>) -->
      ‚Ä¢ Win a district by making sure your party controls <b>more than half</b> the stars in it<br>
      ‚Ä¢ Having an equal amount of red and blue stars result in a split district, which can help either side<br>
      ‚Ä¢ Tap or click a district to remove it and try a different layout<br>
      ‚Ä¢ Win the map by creating more districts for your party
    </div>
    <br>
    <div style="font-weight: bold; font-size: 1.5em;">What is Gerrymandering?</div>
    <div style="font-weight: normal;">Gerrymandering is a political tactic where those in power redraw voting districts to keep themselves in control -
      manipulating the rules to silence opposition and cling to power. It lets politicians pick their voters,
      instead of voters picking their leaders. By slicing communities apart, they can rig outcomes even when they‚Äôre unpopular.
      This game puts you in their shoes. Can you win <i>without winning fair?</i>
    </div>
    <br>
    <div style="display: flex; gap: 24px;">
      <div id="team-toggle" style="z-index: 25;">
        <label for="team-select" style="color: var(--text);">Team Color:</label>
        <select id="team-select">
          <option value="blue">Blue</option>
          <option value="red">Red</option>
        </select>
      </div>

      <div id="theme-toggle" style="z-index: 25;">
        <label for="theme-select" style="color: var(--text);">Theme:</label>
        <select id="theme-select">
          <option value="system">System</option>
          <option value="light">Light</option>
          <option value="dark">Dark</option>
        </select>
      </div>
    </div>
    <br>
    <a id="leveleditor-line" href="https://ssambender.github.io/GM-GEN/" target="_blank">Click here to open level designer page in new tab</a><br>
    <i>( You can reopen this screen at any time with the <span style="font-weight: 900; padding: 0 2px">?</span> at the top right )</i>

    <div style="display: flex; justify-content: center;">
      <button id="start-game-button">BEGIN</button>
    </div>
  </div>
</div>

<div id="finish-modal-container" class="popup-modal-container" style="display: none; z-index: 21">
  <div id="finish-modal" class="popup-modal">
    <div id="finish-close" class="modal-close">+</div>
    <div id="win-message" style="font-weight: bold; font-size: 1.5em; text-transform: uppercase;">Well Done!</div>
    <div style="font-weight: normal; font-size: 1em; margin: 16px 0; color: var(--text);">FINISHED MAP #<span id="map-number-label">0</span> IN <span id="time-spent-label">##:##s</span></div>
    <div id="share-line">Share your time with friends.</div>
  </div>
</div>

<h1 id="heading">
  <div><span style="color: var(--red-letter)">‚òÖ‚òÖ‚òÖ</span> Gerrymandle <span style="color: var(--blue-letter)">‚òÖ‚òÖ‚òÖ</span></div>
  <div id="help-button">?</div>
</h1>

<h2 id="puzzle-info" style="margin-bottom: 0; color: var(--text);">? districts of ?</h2>
<h3 id="puzzle-subinfo" style="margin-top: 0; margin-bottom: 0; font-weight: normal; color: var(--text);"><b style="color: var(--blue-letter)">17</b> - <b style="color: var(--red-letter)">13</b>. Help red win!</h3>
<div id="puzzle-districtbar" style="margin-top: 4px; width: 260px; height: 20px; background: var(--gray-highlight); display: flex; border-radius: 10px; overflow: hidden; margin-bottom: 10px;"></div>
<div id="board-container">
  <canvas id="line-canvas"></canvas>
  <div id="board"></div>
</div>

<div id="timelabel">00:00s</div>

<div id="level-buttons"></div>

<a id="madebysam" href="https://sambender.net">
  Made with ‚ù§Ô∏è by Sam Bender
</a>

<script>
  // get day number (days since aug 1 2025)
  const startDate = new Date("2025-08-01T00:00:00");
  const today = new Date();
  const diffTime = today - startDate;
  let dayOfMap = Math.floor(diffTime / (1000 * 60 * 60 * 24));
  document.getElementById('map-number-label').innerText = dayOfMap;

  
  let gameInProgress = false;
  let helpColorWin = 'Red';

  // board params
  const boardCols = 6;
  const boardRows = 8;


  // LEVELS objects database
  const levels = {
    LVL00: ["16", "3",
      "B", "B", "B", "B", "B", "B",
      "R", "R", "B", "R", "R", "B",
      "R", "R", "B", "R", "R", "B",
      "B", "B", "B", "B", "B", "B",
      "R", "R", "B", "R", "R", "B",
      "R", "R", "B", "R", "R", "B",
      "R", "R", "B", "R", "R", "B",
      "B", "B", "B", "B", "B", "B"
    ],
    LVL01: ["5", "3",
      " ", " ", " ", " ", " ", " ",
      " ", " ", " ", "O", "R", "R",
      "R", "B", "B", "B", "O", " ",
      " ", "B", "B", " ", "O", " ",
      " ", "R", "O", "B", " ", "B",
      " ", "R", "O", "B", " ", " ",
      " ", " ", "R", "B", "O", " ",
      " ", " ", " ", " ", " ", " "
    ],
    LVL02: ["5", "3",
      " ", " ", " ", " ", " ", " ",
      " ", " ", "B", " ", "B", "B",
      " ", "R", "R", "O", "O", " ",
      " ", "R", "B", "B", " ", " ",
      " ", "R", "R", " ", " ", " ",
      "B", "R", "B", " ", " ", " ",
      " ", "B", "B", " ", " ", " ",
      " ", " ", " ", " ", " ", " "
    ],
    LVL03: ["7", "3",
      " ", " ", " ", " ", " ", " ",
      " ", " ", "B", "B", "B", "B",
      " ", " ", "B", "B", "B", " ",
      " ", "B", "B", "R", "O", "R",
      "R", "R", "R", "B", "B", "R",
      "R", "R", "B", "O", "R", " ",
      " ", "O", "O", " ", " ", " ",
      " ", " ", " ", " ", " ", " "
    ],
    LVL04: ["5", "5",
      " ", "R", "B", "O", " ", " ",
      "R", "B", "R", "B", "O", " ",
      " ", "B", "B", "O", "B", "O",
      " ", "B", "O", "B", "O", "B",
      "B", "B", "B", "R", "B", " ",
      " ", " ", "B", "R", "R", " ",
      " ", "B", "R", "R", "O", "R",
      " ", " ", "R", "O", " ", " "
    ],
    LVL05: ["5", "3",
      " ", " ", " ", " ", " ", " ",
      " ", " ", " ", " ", " ", " ",
      "R", "R", "B", "O", " ", " ",
      " ", "B", "B", "B", "B", "R",
      "R", "O", "B", "B", "R", "B",
      "B", " ", "O", "R", " ", " ",
      " ", " ", " ", " ", " ", " ",
      " ", " ", " ", " ", " ", " "
    ],
    LVL06: ["5", "4",
      " ", " ", " ", " ", " ", " ",
      " ", "B", " ", "B", "R", " ",
      "B", " ", "O", "O", "R", "R",
      " ", "O", "B", "B", " ", "O",
      " ", "B", "R", "B", "B", "O",
      "R", "O", "R", "R", "B", "R",
      " ", " ", "B", "R", "B", " ",
      " ", " ", " ", " ", " ", " "
    ],
    LVL07: ["5", "3",
      " ", " ", " ", " ", " ", " ",
      " ", " ", " ", "O", "B", "B",
      "O", "O", "O", "B", "O", "B",
      "B", "R", "R", "B", "O", "O",
      "R", " ", "B", " ", "O", "R",
      " ", " ", " ", "B", "R", "O",
      " ", " ", " ", " ", "R", "B",
      " ", " ", " ", " ", " ", " "
    ],
    LVL08: ["3", "8",
      " ", "R", "B", "B", "B", " ",
      " ", "B", " ", " ", "R", " ",
      " ", "R", " ", " ", "B", " ",
      " ", "B", "R", "B", "B", " ",
      " ", "R", "R", "B", "B", " ",
      " ", "B", " ", " ", "R", " ",
      " ", "B", " ", " ", "R", " ",
      " ", "R", "R", "B", "R", " "
    ],
    LVL09: ["5", "5",
      " ", " ", " ", " ", "B", "B",
      " ", " ", " ", "R", "B", "O",
      "B", "R", "R", "B", "B", " ",
      " ", " ", "O", " ", "B", "R",
      "R", "B", "B", " ", "B", "B",
      " ", " ", "B", " ", "R", "R",
      " ", " ", " ", "R", "R", "B",
      " ", " ", " ", "R", "B", "B"
    ],
    LVL10: ["5", "6",
      " ", "R", " ", "B", "B", " ",
      "R", "B", "B", "R", "B", "R",
      "B", "R", "B", "B", "R", " ",
      " ", "B", "R", "B", "O", "B",
      "R", "O", "R", "B", "B", " ",
      "R", "B", "R", " ", "R", "B",
      " ", "R", "B", "B", "O", " ",
      " ", " ", " ", " ", " ", " "
    ]
  };


  // convert css vars to non-variable codes
  const styleVars = getComputedStyle(document.documentElement);


  // create one button for each level object in levels database - not permanent
  function generateLevelButtons() {
    const container = document.getElementById("level-buttons");
    for (const key in levels) {
      const btn = document.createElement("button");
      btn.innerText = key;
      btn.onclick = () => loadLevel(key);
      container.appendChild(btn);
    }
  }
  generateLevelButtons();


  let currentDistrictCount = 0;
  let currentVoteCount = 0;
  let levelData = [];
  let finalizedDistricts = [];


  // CHARACTER SYMBOLS TO DISPLAY
  // ‚òÖ‚úØ‚ú©‚ú∞   ‚ú™   ‚ú¶‚úß   R üü• B üü¶ W ‚¨ú
  function getDisplayCharacter(char) {
    if (helpColorWin === "red") {
      switch (char) {
        case "R": return "‚òÖ";
        case "B": return "‚ú™";
        case "O": return "‚ú©";
        default: return " ";
      }
    }
    else {
      switch (char) {
        case "R": return "‚ú™";
        case "B": return "‚òÖ";
        case "O": return "‚ú©";
        default: return " ";
      }
    }
  }


  // LOAD TILES ON BOARD
  function loadLevel(levelName) {
    if (!levels[levelName]) return;

    board.style.pointerEvents = "auto";

    const data = levels[levelName];

    currentDistrictCount = parseInt(data[0]);
    currentVoteCount = parseInt(data[1]);

    // Update levelData
    levelData.length = 0;
    levelData.push(...data);

    // Clear previous state
    finalizedDistricts = [];
    board.innerHTML = "";
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // Rebuild board
    let index = 2; // skip the first two (district x vote var counts)
    for (let row = 0; row < boardRows; row++) {
      for (let col = 0; col < boardCols; col++) {
        const tile = document.createElement("div");
        tile.classList.add("tile");

        const letter = data[index] || "";
        //tile.dataset.value = letter;
        tile.dataset.value = letter; // store actual value for logic
        tile.innerText = getDisplayCharacter(letter); // show visual representation
        if (letter === "B") {
          //tile.style.color = styleVars.getPropertyValue('--blue-letter').trim();
          if (helpColorWin === "red") {
            tile.classList.add("tile-blue");
          }
          else {
            tile.classList.add("tile-red");
          }
          tile.style.cursor = "pointer";
        }
        if (letter === "R") {
          //tile.style.color = styleVars.getPropertyValue('--red-letter').trim();
          if (helpColorWin === "red") {
            tile.classList.add("tile-red");
          }
          else {
            tile.classList.add("tile-blue");
          }
          tile.style.cursor = "pointer";
        }
        if (letter === "O") {
          //tile.style.color = styleVars.getPropertyValue('--gray-letter').trim();
          tile.classList.add("tile-gray");
          tile.style.cursor = "pointer";
        }

        tile.dataset.row = row;
        tile.dataset.col = col;

        tile.addEventListener("click", () => {
          if (isTileFinalized(tile)) {
            removeDistrictContainingTile(tile);
            drawLines();
          }
        });

        board.appendChild(tile);
        index++;
      }
    }

    setInfo();
    updateVoteTotals();
    updateDistrictBar();
    resizeCanvas();
  }


  // init and state vars
  const board = document.getElementById("board");
  const canvas = document.getElementById("line-canvas");
  const ctx = canvas.getContext("2d");
  let isMouseDown = false;
  let path = [];


  // redraw canvas
  function resizeCanvas() {
    const container = document.getElementById("board-container");

    const width = container.offsetWidth;
    const height = container.offsetHeight;

    canvas.width = width;
    canvas.height = height;

    canvas.style.width = width + "px";
    canvas.style.height = height + "px";

    drawLines(); // redraw after resize
  }
  resizeCanvas();


  // update the info - title
  function setInfo() {
    document.getElementById('puzzle-info').innerText = `${currentDistrictCount} districts of ${currentVoteCount}`;  // no date
  }

  // update the subinfo line - blue & red star count
  function updateVoteTotals() {
    const rTotal = levelData.filter(cell => cell === "R").length;
    const bTotal = levelData.filter(cell => cell === "B").length;

    const subInfo = document.getElementById('puzzle-subinfo');
    if (helpColorWin === "red") {
      subInfo.innerHTML = `<b style="color: #5988d1">${bTotal}</b> - <b style="color: #e05353">${rTotal}</b>. Help <b>${helpColorWin}</b> win!`;
    }
    else {
      subInfo.innerHTML = `<b style="color: #e05353">${bTotal}</b> - <b style="color: #5988d1">${rTotal}</b>. Help <b>${helpColorWin}</b> win!`;
    }
  }
  setInfo();
  updateVoteTotals();


  // update the district percent indicator bar
  function updateDistrictBar() {
    const bar = document.getElementById("puzzle-districtbar");

    const styleVars = getComputedStyle(document.documentElement);
    const total = currentDistrictCount;
    let red = 0, blue = 0, purple = 0;

    finalizedDistricts.forEach(d => {
      if (d.colorClass === "selected-red") red++;
      else if (d.colorClass === "selected-blue") blue++;
      else if (d.colorClass === "selected-purple") purple++;
    });

    const remaining = total - red - blue - purple;

    const segments = [
      { key: "red", count: red, color: styleVars.getPropertyValue('--red-highlight').trim() },
      { key: "blue", count: blue, color: styleVars.getPropertyValue('--blue-highlight').trim() },
      { key: "purple", count: purple, color: styleVars.getPropertyValue('--purple-highlight').trim() },
      { key: "gray", count: remaining, color: styleVars.getPropertyValue('--gray-highlight').trim() }
    ];

    // Update or create segments
    segments.forEach((seg, i) => {
      let segment = bar.children[i];
      const desiredWidth = `${(seg.count / total) * 100}%`;

      if (!segment) {
        // New segment
        segment = document.createElement("div");
        segment.className = "district-segment";
        segment.style.background = seg.color;
        segment.style.width = "0";
        // segment.title = desiredWidth;
        bar.appendChild(segment);
        requestAnimationFrame(() => {
          segment.style.width = desiredWidth;
        });
      } else {
        // Existing segment: update color & width only if changed
        if (segment.style.background !== seg.color) {
          segment.style.background = seg.color;
        }
        if (segment.style.width !== desiredWidth) {
          segment.style.width = desiredWidth;
        }
      }
    });

    // Remove extra segments if any
    while (bar.children.length > segments.length) {
      bar.removeChild(bar.lastChild);
    }
  }


  // helper func for line drawing
  function getTileCenter(tile) {
    const rect = tile.getBoundingClientRect();
    const parentRect = board.getBoundingClientRect();
    return {
      x: rect.left - parentRect.left + rect.width / 2,
      y: rect.top - parentRect.top + rect.height / 2
    };
  }


  // Draw lines connecting tiles for given path with specified color and line width
  function drawPathLines(pathTiles, color, lineWidth = 16) {
    if (pathTiles.length < 2) return;
    ctx.strokeStyle = color;
    ctx.lineWidth = lineWidth;
    ctx.lineCap = "round";
    ctx.beginPath();
    const start = getTileCenter(pathTiles[0]);
    ctx.moveTo(start.x, start.y);
    for (let i = 1; i < pathTiles.length; i++) {
      const point = getTileCenter(pathTiles[i]);
      ctx.lineTo(point.x, point.y);
    }
    ctx.stroke();
  }


  // update connecting line colors
  function updateCurrentPathColors() {
    if (path.length === 0) return;

    const votes = path.map(t => t.dataset.value);
    const rCount = votes.filter(v => v === "R").length;
    const bCount = votes.filter(v => v === "B").length;

    // Remove all color classes first
    path.forEach(t => {
      t.classList.remove("selected", "selected-red", "selected-blue", "selected-purple");
    });

    const voteCount = path.filter(t => {
      const val = t.dataset.value.trim();
      return val === "R" || val === "B";
    }).length;

    if (voteCount >= currentVoteCount) {
      // Apply matching color class
      if (helpColorWin === "red") {
        if (rCount > bCount) {
          path.forEach(t => t.classList.add("selected-red"));
        } else if (bCount > rCount) {
          path.forEach(t => t.classList.add("selected-blue"));
        } else {
          path.forEach(t => t.classList.add("selected-purple"));
        }
      }
      else {
        if (bCount > rCount) {
          path.forEach(t => t.classList.add("selected-red"));
        } else if (rCount > bCount) {
          path.forEach(t => t.classList.add("selected-blue"));
        } else {
          path.forEach(t => t.classList.add("selected-purple"));
        }
      }
    } else {
      // Not full length apply default selected bg
      path.forEach(t => t.classList.add("selected"));
    }
  }


  // draws all finalized districts lines plus current drawing path line
  function drawLines() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // Draw finalized districts lines first
    finalizedDistricts.forEach(district => {
      const color = getStrokeColorForClass(district.colorClass);
      drawPathLines(district.tiles, color);
    });

    // Draw current path line if any
    if (path.length < 2) return;

    const voteCount = path.filter(t => {
      const val = t.dataset.value.trim();
      return val === "R" || val === "B";
    }).length;

    if (voteCount >= currentVoteCount) {
      const strokeColor = finalizePathColor();
      drawPathLines(path, strokeColor);
    } else {
      const gray = styleVars.getPropertyValue('--gray-highlight').trim();
      drawPathLines(path, gray);
    }

  }


  // get stroke color string for given tile class
  function getStrokeColorForClass(colorClass) {
    switch (colorClass) {
      case "selected-red": return styleVars.getPropertyValue('--red-highlight').trim();
      case "selected-blue": return styleVars.getPropertyValue('--blue-highlight').trim();
      case "selected-purple": return styleVars.getPropertyValue('--purple-highlight').trim();
      default: return styleVars.getPropertyValue('--gray-highlight').trim();
    }
  }


  // check if tiles are adjacent on grid
  function areAdjacent(tile1, tile2) {
    const r1 = +tile1.dataset.row;
    const c1 = +tile1.dataset.col;
    const r2 = +tile2.dataset.row;
    const c2 = +tile2.dataset.col;

    const rowDiff = r2 - r1;
    const colDiff = c2 - c1;

    const absRow = Math.abs(rowDiff);
    const absCol = Math.abs(colDiff);

    if (absRow > 1 || absCol > 1 || (absRow === 0 && absCol === 0)) return false;

    // Diagonal move
    if (absRow === 1 && absCol === 1) {
      const midTileA = document.querySelector(`[data-row="${r1}"][data-col="${c2}"]`);
      const midTileB = document.querySelector(`[data-row="${r2}"][data-col="${c1}"]`);

      // Check if either of the mid-tiles are connected by a finalized district
      for (const district of finalizedDistricts) {
        if (
                midTileA && midTileB &&
                district.tiles.includes(midTileA) &&
                district.tiles.includes(midTileB)
        ) {
          // They're both in a district ‚Äî check if they're directly connected
          const idxA = district.tiles.indexOf(midTileA);
          const idxB = district.tiles.indexOf(midTileB);
          if (Math.abs(idxA - idxB) === 1) {
            return false; // A connector exists ‚Äî block diagonal
          }
        }
      }
    }

    return true;
  }



  // REMOVE AN EXISTING DISTRICT
  // clear the path
  function clearPath() {
    path.forEach(t => {
      if (!isTileFinalized(t)) {
        t.classList.remove("selected", "selected-red", "selected-blue", "selected-purple");
      }
    });
    path = [];
    drawLines();
  }

  // check tiles
  function isTileFinalized(tile) {
    return finalizedDistricts.some(district => district.tiles.includes(tile));
  }

  // get tile and connected tiles to remove
  function removeDistrictContainingTile(tile) {
    for (let i = 0; i < finalizedDistricts.length; i++) {
      const district = finalizedDistricts[i];
      if (district.tiles.includes(tile)) {
        // Log what colord district is removed
        let colorName = "purple";
        if (district.colorClass === "selected-red") colorName = "red";
        else if (district.colorClass === "selected-blue") colorName = "blue";
        console.log(`${colorName} district removed`);

        district.tiles.forEach(t => {
          t.classList.remove("selected-red", "selected-blue", "selected-purple");
        });
        finalizedDistricts.splice(i, 1);

        // Log updated totals
        let redCount = 0, blueCount = 0, purpleCount = 0;
        finalizedDistricts.forEach(d => {
          if (d.colorClass === "selected-red") redCount++;
          else if (d.colorClass === "selected-blue") blueCount++;
          else if (d.colorClass === "selected-purple") purpleCount++;
        });
        console.log(`total red: ${redCount}, total blue: ${blueCount}, total purple: ${purpleCount}`);

        updateDistrictBar();

        break;
      }
    }
  }



  // SHARE DATA AND SHARE LINK
  let timeSpentString = "0";
  let shareData = {
    title: 'Gerrymandle #' + dayOfMap,
    text: `üî∏I beat map #${dayOfMap}` + ` in ${timeSpentString}. üó∫Ô∏è \nüîπThink you can solve it faster?\nhttps://ssambender.github.io/gerrymandle/`,
    //url: 'https://ssambender.github.io/gerrymandle/'
  }
  let sharelink = document.getElementById('share-line');
  sharelink.addEventListener('click', async (event) => {
    event.preventDefault();

    // Update the share text with the latest time string
    shareData.text = `üî∏I beat map #${dayOfMap} in ${timeSpentString}. üó∫Ô∏è\nüîπThink you can solve it faster?\nhttps://ssambender.github.io/gerrymandle/`;

    try {
      await navigator.share(shareData);
      console.log('shared successfully');
    } catch (err) {
      console.log('error: ' + err);
    }
  }, false);



  // EVENT LISTENERS
  // mouse down
  board.addEventListener("mousedown", (e) => {
    if (!e.target.classList.contains("tile")) return;
    if (isTileFinalized(e.target)) return;
    if (e.target.dataset.value.trim() === "") return;  //prevents selecting blank spaces

    clearPath();
    isMouseDown = true;

    path.push(e.target);
    updateCurrentPathColors();
    drawLines();

    e.target.classList.add("pop");
    e.target.addEventListener("animationend", () => {
      e.target.classList.remove("pop");
    }, { once: true });
  });
  // touch down
  board.addEventListener("touchstart", (e) => {
    const touch = e.touches[0];
    const target = document.elementFromPoint(touch.clientX, touch.clientY);
    if (!target || !target.classList.contains("tile")) return;
    if (isTileFinalized(target)) return;
    if (target.dataset.value.trim() === "") return;

    clearPath();
    isMouseDown = true;

    path.push(target);
    updateCurrentPathColors();
    drawLines();

    target.classList.add("pop");
    target.addEventListener("animationend", () => {
      target.classList.remove("pop");
    }, { once: true });

    e.preventDefault();
  }, { passive: false });

  // mouse drag
  board.addEventListener("mouseover", (e) => {
    if (!isMouseDown || !e.target.classList.contains("tile")) return;
    if (isTileFinalized(e.target)) return;

    const currentTile = e.target;
    if (currentTile.dataset.value.trim() === "") return;  //prevents selecting blank spaces

    const last = path[path.length - 1];
    const secondLast = path[path.length - 2];

    // Allow retreating
    if (secondLast === currentTile) {
      const removed = path.pop();
      removed.classList.remove("selected", "selected-red", "selected-blue", "selected-purple");
      updateCurrentPathColors();
      drawLines();
      return;
    }

    const voteCount = path.filter(t => {
      const val = t.dataset.value.trim();
      return val === "R" || val === "B";
    }).length;

    const atLimit = voteCount >= currentVoteCount;

    if (atLimit) return;

    if (!path.includes(currentTile) && areAdjacent(last, currentTile)) {
      path.push(currentTile);
      updateCurrentPathColors();
      drawLines();

      currentTile.classList.add("pop");
      currentTile.addEventListener("animationend", () => {
        currentTile.classList.remove("pop");
      }, { once: true });
    }
  });
  // touch drag
  board.addEventListener("touchmove", (e) => {
    if (!isMouseDown) return;

    const touch = e.touches[0];
    const target = document.elementFromPoint(touch.clientX, touch.clientY);
    if (!target || !target.classList.contains("tile")) return;
    if (isTileFinalized(target)) return;
    if (target.dataset.value.trim() === "") return;

    const last = path[path.length - 1];
    const secondLast = path[path.length - 2];

    if (secondLast === target) {
      const removed = path.pop();
      removed.classList.remove("selected", "selected-red", "selected-blue", "selected-purple");
      updateCurrentPathColors();
      drawLines();
      return;
    }

    const voteCount = path.filter(t => ["R", "B"].includes(t.dataset.value)).length;
    const atLimit = voteCount >= currentVoteCount;

    if (atLimit) return;

    if (!path.includes(target) && areAdjacent(last, target)) {
      path.push(target);
      updateCurrentPathColors();
      drawLines();

      target.classList.add("pop");
      target.addEventListener("animationend", () => {
        target.classList.remove("pop");
      }, { once: true });
    }

    e.preventDefault();
  }, { passive: false });

  // mouse up
  window.addEventListener("mouseup", () => {
    if (path.length > 0) {
      const word = path.map(t => t.dataset.value).join("");
      // console.log("Selected word:", word);

      const voteCount = path.filter(t => {
        const val = t.dataset.value.trim();
        return val === "R" || val === "B";
      }).length;

      if (voteCount === currentVoteCount) {
        // Finalize district
        const colorClass = getFinalColorClass();

        finalizedDistricts.push({
          tiles: [...path],
          colorClass
        });

        // remove temp selected class and apply final color class only
        path.forEach(t => {
          t.classList.remove("selected");
          t.classList.add(colorClass);
        });

        // log district color drawn
        let colorName = "purple";
        if (colorClass === "selected-red") colorName = "red";
        else if (colorClass === "selected-blue") colorName = "blue";
        console.log(`${colorName} district drawn`);

        // Count totals
        let redCount = 0, blueCount = 0, purpleCount = 0;
        finalizedDistricts.forEach(district => {
          if (district.colorClass === "selected-red") redCount++;
          else if (district.colorClass === "selected-blue") blueCount++;
          else if (district.colorClass === "selected-purple") purpleCount++;
        });
        console.log(`total red: ${redCount}, total blue: ${blueCount}, total purple: ${purpleCount}`);

        updateDistrictBar();

        if (finalizedDistricts.length === currentDistrictCount) {
          console.log("all districts drawn");
          if ((helpColorWin === "red" && redCount > blueCount) || (helpColorWin === "blue" && redCount < blueCount)) {
            console.log("LEVEL WIN!");
            console.log("Well Done!");
            stopTimer();

            const minutes = String(Math.floor(elapsedSeconds / 60)).padStart(2, '0');
            const seconds = String(elapsedSeconds % 60).padStart(2, '0');
            document.getElementById('time-spent-label').innerText = `${minutes}:${seconds}s`;

            // share data timer
            if ( Math.floor(elapsedSeconds / 60) < 1 ) {
              timeSpentString = `${String(elapsedSeconds % 60)}s`;
            }
            else {
              timeSpentString = `${String(Math.floor(elapsedSeconds / 60))}m ${String(elapsedSeconds % 60)}s`;
            }

            board.style.pointerEvents = "none";  // stop board edits after win
            //board.style.pointerEvents = "auto";  // to reenable events on board reset or something

            document.querySelectorAll('.tile').forEach(tile => {
              const row = parseInt(tile.dataset.row);
              const col = parseInt(tile.dataset.col);
              const delay = (row * boardCols + col) * 15;
              setTimeout(() => {
                tile.classList.add('fade-text');
              }, delay);
            });

            document.getElementById('finish-modal-container').style.display = 'flex';
            document.getElementById('finish-modal-container').style.opacity = '0';
            setTimeout(() => {
              document.getElementById('finish-modal-container').style.display = 'flex';
              document.getElementById('finish-modal-container').style.opacity = '1';
            }, 1500);
          }
          else {
            console.log("NOT QUITE!");
            // todo - show up "reset?" button
          }
        }

        path = [];
        drawLines();
      } else {
        clearPath();
      }
    }
    isMouseDown = false;
  });
  // touch up - todo: possibly change board to window for touchend below
  board.addEventListener("touchend", (e) => {
    if (path.length === 0) return;

    e.preventDefault();
    isMouseDown = false;

    const voteTiles = path.filter(t => ["R", "B"].includes(t.dataset.value.trim()));
    const voteCount = voteTiles.length;

    if (voteCount === currentVoteCount && path.length >= voteCount) {
      const colorClass = getFinalColorClass();

      finalizedDistricts.push({
        tiles: [...path],
        colorClass
      });

      path.forEach(t => {
        t.classList.remove("selected");
        t.classList.add(colorClass);
      });

      updateDistrictBar();

      // Win check logic
      const redCount = finalizedDistricts.filter(d => d.colorClass === "selected-red").length;
      const blueCount = finalizedDistricts.filter(d => d.colorClass === "selected-blue").length;

      if (finalizedDistricts.length === currentDistrictCount) {
        if ((helpColorWin === "red" && redCount > blueCount) ||
                (helpColorWin === "blue" && blueCount > redCount)) {
          console.log("LEVEL WIN!");
          stopTimer();

          const minutes = String(Math.floor(elapsedSeconds / 60)).padStart(2, '0');
          const seconds = String(elapsedSeconds % 60).padStart(2, '0');
          document.getElementById('time-spent-label').innerText = `${minutes}:${seconds}s`;

          // share data timer
          if ( Math.floor(elapsedSeconds / 60) < 1 ) {
            timeSpentString = `${String(elapsedSeconds % 60)}s`;
          }
          else {
            timeSpentString = `${String(Math.floor(elapsedSeconds / 60))}m ${String(elapsedSeconds % 60)}s`;
          }

          board.style.pointerEvents = "none";  // stop board edits after win

          document.querySelectorAll('.tile').forEach(tile => {
            const row = parseInt(tile.dataset.row);
            const col = parseInt(tile.dataset.col);
            const delay = (row * boardCols + col) * 15;
            setTimeout(() => {
              tile.classList.add('fade-text');
            }, delay);
          });

          document.getElementById('finish-modal-container').style.display = 'flex';
          document.getElementById('finish-modal-container').style.opacity = '0';
          setTimeout(() => {
            document.getElementById('finish-modal-container').style.display = 'flex';
            document.getElementById('finish-modal-container').style.opacity = '1';
          }, 1500);
        }
      }

      path = [];
      drawLines();
    } else {
      clearPath();
    }
  }, { passive: false });

  // detect mouse leave
  window.addEventListener("mouseleave", () => {
    isMouseDown = false;
  });

  // detect window resize
  window.addEventListener("resize", () => {
    resizeCanvas();
    drawLines();
  });



  // FINALIZE DISTRICT COORS
  function getFinalColorClass() {
    const votes = path
            .map(t => t.dataset.value)
            .filter(v => v !== "O");
    const rCount = votes.filter(v => v === "R").length;
    const bCount = votes.filter(v => v === "B").length;

    if (helpColorWin === "red") {
      if (rCount > bCount) return "selected-red";
      else if (bCount > rCount) return "selected-blue";
      else return "selected-purple";
    }
    else {
      if (rCount > bCount) return "selected-blue";
      else if (bCount > rCount) return "selected-red";
      else return "selected-purple";
    }
  }
  function finalizePathColor() {
    const votes = path
            .map(t => t.dataset.value)
            .filter(v => v !== "O");
    const rCount = votes.filter(v => v === "R").length;
    const bCount = votes.filter(v => v === "B").length;

    if (helpColorWin === "red") {
      if (rCount > bCount) return styleVars.getPropertyValue('--red-highlight').trim();
      else if (bCount > rCount) return styleVars.getPropertyValue('--blue-highlight').trim();
      else return styleVars.getPropertyValue('--purple-highlight').trim();
    }
    else {
      if (rCount > bCount) return styleVars.getPropertyValue('--blue-highlight').trim();
      else if (bCount > rCount) return styleVars.getPropertyValue('--red-highlight').trim();
      else return styleVars.getPropertyValue('--purple-highlight').trim();
    }
  }



  // START AND FINISH MODALS
  // close win modal
  document.getElementById('finish-close').addEventListener("click", () => {
    document.getElementById('finish-modal-container').style.display = 'none';
    document.getElementById('finish-modal-container').style.opacity = '0';
  });

  // start modal - BEGIN button pressed - begin game start game
  document.getElementById('start-game-button').addEventListener("click", () => {
    document.getElementById('start-modal-container').style.display = 'none';
    document.getElementById('start-modal-container').style.opacity = '0';

    // START LEVEL
    startTimer();

    document.body.scrollTop = document.documentElement.scrollTop = 0;

    gameInProgress = true;
    document.getElementById('team-select').disabled = true;
    if (document.getElementById('team-select').value === "red") {
      helpColorWin = "red";
    }
    else {
      helpColorWin = "blue";
    }
    updateVoteTotals();
    loadLevel('LVL01');

    document.body.style.overflowY = 'visible';
    document.getElementById('start-game-button').style.display = 'none';
    document.getElementById('start-modal').style.padding = '48px';
    document.getElementById('start-close').style.display = 'flex';

    document.getElementById('help-button').style.visibility = 'visible';
    document.getElementById('help-button').style.pointerEvents = 'all';
  })

  // close help modal
  document.getElementById('start-close').addEventListener("click", () => {
    document.getElementById('start-modal-container').style.display = 'none';
    document.getElementById('start-modal-container').style.opacity = '0';
  });

  // open help modal
  document.getElementById('help-button').addEventListener("click", () => {
    document.getElementById('start-modal-container').style.display = 'flex';
    document.getElementById('start-modal-container').style.opacity = '1';
    document.getElementById('start-modal-container').style.background = 'var(--bg-opacity)';
  });

  // prevent flicker on pageload (when selected theme and system theme don't match)
  setTimeout(() => {
    document.getElementById('start-game-button').style.transition = "color .15s, border .15s";
  }, 200);



  // LIGHT/DARK THEME
  const themeSelect = document.getElementById("theme-select");

  // auto check theme preference
  window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', (e) => {
    console.log("Color scheme changed:", e.matches ? "dark" : "light");
    drawLines(); // Redraw canvas lines with updated CSS variable colors
    updateDistrictBar();
  });

  // Load saved preference
  const savedTheme = localStorage.getItem("theme");
  if (savedTheme) {
    themeSelect.value = savedTheme;
    if (savedTheme === "system") {
      document.documentElement.removeAttribute("data-theme");

      // Manualy force updates using current system preference
      const isDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
      console.log("Using system theme:", isDark ? "dark" : "light");
    } else {
      document.documentElement.setAttribute("data-theme", savedTheme);
    }

    // Always refresh visuals on page load based on theme
    drawLines();
    updateDistrictBar();
  }

  // On theme selectchange
  themeSelect.addEventListener("change", () => {
    const theme = themeSelect.value;
    localStorage.setItem("theme", theme);
    if (theme === "system") {
      document.documentElement.removeAttribute("data-theme");
    } else {
      document.documentElement.setAttribute("data-theme", theme);
    }

    // Refresh visuals
    drawLines();
    updateDistrictBar();
  });

  // force recheck when system theme changes
  window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', () => {
    if (themeSelect.value === "system") {
      drawLines();
      updateDistrictBar();
    }
  });



  // LOAD RED/BLUE THEME
  const teamSelect = document.getElementById('team-select');

  const savedTeam = localStorage.getItem("team");
  if (savedTeam) {
    teamSelect.value = savedTeam;
    if (savedTeam === "red") {
      // set red team by default
      console.log("loaded saved localstorage color red");
    } else {
      // set blue team by default
      console.log("loaded saved localstorage color blue");
    }
  }
  else {
    console.log("no saved localstorage color");
    console.log("setting default to blue");
    localStorage.setItem("team", "blue");
  }

  // On team select change
  teamSelect.addEventListener("change", () => {
    const teamColor = teamSelect.value;
    localStorage.setItem("team", teamColor);
    console.log("set localStorage team color to " + teamColor);
  });



  // TIMER
  let elapsedSeconds = 0;
  let timerInterval = null;

  function updateDisplay() {
    const minutes = String(Math.floor(elapsedSeconds / 60)).padStart(2, '0');
    const seconds = String(elapsedSeconds % 60).padStart(2, '0');
    document.getElementById('timelabel').textContent = `${minutes}:${seconds}s`;
  }

  function startTimer() {
    if (timerInterval) return; // prevent multiple intervals
    timerInterval = setInterval(() => {
      elapsedSeconds++;
      updateDisplay();
    }, 1000);
  }

  function stopTimer() {
    clearInterval(timerInterval);
    timerInterval = null;
  }
</script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Gerrymandle</title>
  <link rel="icon" href="https://raw.githubusercontent.com/ssambender/gerrymandle/refs/heads/main/g-logo.png">
  <link rel="apple-touch-icon" href="https://raw.githubusercontent.com/ssambender/gerrymandle/refs/heads/main/g-logo.png">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Zain:ital,wght@0,200;0,300;0,400;0,700;0,800;0,900;1,300;1,400&display=swap" rel="stylesheet">
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Zain:ital,wght@0,200;0,300;0,400;0,700;0,800;0,900;1,300;1,400&display=swap');

    :root {
      --bg: #ffffff;
      --bg-opacity: rgba(255, 255, 255, 0.75);
      --text: #55698c;

      --gray-highlight: #E8E8E8;
      --red-highlight: #eeb5ae;
      --blue-highlight: #aed1ee;
      --purple-highlight: #ddc6ea;

      --gray-letter: #dadada;
      --red-letter: #e05353;
      --blue-letter: #5988d1;
    }
    /* Override light theme manually */
    html[data-theme="light"] {
      --bg: #ffffff;
      --bg-opacity: rgba(255, 255, 255, 0.75);
      --text: #55698c;
      --gray-highlight: #E8E8E8;
      --red-highlight: #eeb5ae;
      --blue-highlight: #aed1ee;
      --purple-highlight: #ddc6ea;
      --gray-letter: #dadada;
      --red-letter: #e05353;
      --blue-letter: #5988d1;
    }

    /* Override dark theme manually */
    html[data-theme="dark"] {
      --bg: #242f3b;
      --bg-opacity: rgba(36, 47, 59, 0.75);
      --text: #ffffff;
      --gray-highlight: #424f5e;
      --red-highlight: #803026;
      --blue-highlight: #164c7d;
      --purple-highlight: #5f436f;
      --gray-letter: #6e7a86;
      --red-letter: #e05353;
      --blue-letter: #5988d1;
    }

    /* Fallback for system preference (only used if no manual override) */
    @media (prefers-color-scheme: dark) {
      html:not([data-theme]) {
        --bg: #242f3b;
        --bg-opacity: rgba(36, 47, 59, 0.75);
        --text: #ffffff;
        --gray-highlight: #424f5e;
        --red-highlight: #803026;
        --blue-highlight: #164c7d;
        --purple-highlight: #5f436f;
        --gray-letter: #6e7a86;
        --red-letter: #e05353;
        --blue-letter: #5988d1;
      }
    }

    body {
      font-family: 'Zain', 'Clear Sans', 'Helvetica Neue', 'Franklin Gothic Demi Cond', 'Bahnschrift', Arial, sans-serif;
      background: var(--bg);
      display: flex;
      flex-direction: column;
      /*justify-content: center;*/
      align-items: center;
      margin: 0;
      min-height: 100vh;
    }
    @media (min-width: 1060px) {
      body {
        max-height: 100vh;
      }
    }

    button {
      font-family: 'Zain', 'Clear Sans', 'Helvetica Neue', 'Franklin Gothic Demi Cond', 'Bahnschrift', Arial, sans-serif;
      padding-top: 4px;
    }

    #heading {
      color: var(--text);
      font-weight: normal;
      text-transform: uppercase;
      margin-bottom: 0;
      border-bottom: 1px solid var(--gray-highlight);
      width: 100%;
      text-align: center;

      z-index: 20;

      margin-top: 0;
      display: flex;
      justify-content: center;
      align-items: center;
      line-height: 1;
      padding: 14px 0 8px;
    }
    #title-click {
      cursor: pointer;
    }

    #help-button {
      position: absolute;
      right: 48px;
      cursor: pointer;
      user-select: none;
      visibility: hidden;
      pointer-events: none;
      font-weight: 800;
    }

    #theme-select, #team-select {
      color: var(--text);
      font-weight: bold;
      background: var(--bg);
      outline: none;
      border: solid 2px var(--gray-highlight);
    }
    #theme-select:disabled, #team-select:disabled {
      pointer-events: none;
      opacity: 0.5;
      user-select: none;
    }

    .popup-modal-container {
      position: absolute;
      width: 100vw;
      height: 100vh;
      background-color: var(--bg-opacity);
      z-index: 10;
      display: flex;
      justify-content: center;
      align-items: center;
      color: var(--text);
      text-align: center;
      transition: opacity 1s;
    }
    #start-modal-container.popup-modal-container {
      background-color: var(--bg);
    }
    .popup-modal {
      background-color: var(--bg);
      padding: 48px;
      /*border-radius: 36px;*/
      border: solid 2px var(--gray-highlight);
      color: var(--text);
      cursor: default;
      position: relative;
    }

    #share-line {
      text-decoration: underline;
      color: var(--blue-highlight);
      transition: color .15s;
    }
    #share-line:hover {
      cursor: pointer;
      color: var(--blue-letter);
    }
    .modal-close {
      position: absolute;
      top: 12px;
      right: 24px;
      transform: rotate(45deg);
      font-weight: 700;
      font-size: 2em;
      cursor: pointer;
      color: var(--red-highlight);
      transition: color .15s;
    }
    .modal-close:hover {
      color: var(--red-letter);
    }

    .leveleditor-line {
      text-decoration: underline;
      color: var(--blue-highlight);
      transition: color .15s;
    }
    .leveleditor-line:hover {
      cursor: pointer;
      color: var(--blue-letter);
    }

    #start-modal {
      max-width: 30vw;
      padding: 48px 48px 24px 48px;
    }

    #start-game-button {
      background: none;
      outline: none;
      color: var(--gray-letter);
      border: solid 2px var(--gray-highlight);
      /*transition: color .15s, border .15s;*/
      cursor: pointer;
      font-size: 1.5em;
      padding: 12px 24px 8px;
      border-radius: 8px;
      margin-top: 24px;
    }
    #start-game-button:hover {
      color: var(--text);
      border: solid 2px var(--text);
    }

    @media all and (orientation: portrait) {
      #heading {
        font-size: 1.5em;
      }
      #puzzle-info {
        font-size: 1.25em;
      }
      #start-modal {
        max-width: 50%;
      }
      #start-modal-container {
        z-index: 24;
      }
      #help-button {
        right: 24px;
      }

      .popup-modal {
        position: absolute;
        top: 0;
      }
      #finish-modal {
        position: relative;
      }

      .leveleditor-line {
        text-decoration: underline;
        color: var(--blue-letter);
        transition: color .15s;
      }
      #share-line {
        color: var(--blue-letter);
      }
    }

    #board-container {
      position: relative;
      width: 460px;
      height: 620px;
      min-height: 620px;

      /* center board within container on mobile */
      display: flex;
      justify-content: center;
      align-items: center;
    }

    #board {
      display: grid;
      grid-template-columns: repeat(6, 60px);
      grid-template-rows: repeat(8, 60px);
      gap: 20px;
      position: absolute;
      z-index: 2;

      /* stop accidental scroll on mobile */
      touch-action: none;
    }

    .tile {
      width: 60px;
      height: 60px;
      border-radius: 50%;
      background: var(--bg);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 28px;
      font-weight: bold;
      color: var(--text);
      /*cursor: pointer;*/
      user-select: none;
      /*line-height: 1;*/
      /*vertical-align: middle;*/
    }

    /* Highlight classes */
    .tile.selected {
      background: var(--gray-highlight);
    }
    .tile.selected-red {
      background: var(--red-highlight);
    }
    .tile.selected-blue {
      background: var(--blue-highlight);
    }
    .tile.selected-purple {
      background: var(--purple-highlight);
    }

    .tile-red {
      color: var(--red-letter);
    }
    .tile-blue {
      color: var(--blue-letter);
    }
    .tile-gray {
      color: var(--gray-letter);
    }

    #line-canvas {
      position: absolute;
      top: 0;
      left: 0;
      z-index: 1;
      pointer-events: none;
    }

    #timelabel {
      color: var(--text);
    }

    #level-buttons {
      display: none;
      flex-wrap: nowrap;
      gap: 12px;
      margin-top: 4px;

      padding-bottom: 4px;
      overflow-x: scroll;
    }
    #level-buttons button {
      background: var(--bg);
      outline: none;
      border: solid 2px var(--gray-highlight);
      color: var(--gray-letter);
      cursor: pointer;
    }
    #level-buttons button:hover {
      color: var(--text);
      border: solid 2px var(--text);
    }

    #madebysam {
      color: var(--text);
      cursor: pointer;
      margin-top: 36px;
      padding-bottom: 12px;
      text-align: center;
      font-size: 0.9rem;
      text-decoration: none;
      font-weight: bold;
    }
    #madebysam:hover {
      text-decoration: underline;
    }

    @keyframes pop {
      0%   { transform: scale(1); }
      30%  { transform: scale(1.1); }
      60%  { transform: scale(0.95); }
      100% { transform: scale(1); }
    }

    .tile.pop {
      animation: pop 250ms ease-out;
    }
    .tile.fade-text {
      transition: color 1s ease;
      color: transparent !important;
    }

    .district-segment {
      height: 100%;
      transition: width 0.3s ease;
    }

    @media (max-width: 619px) {
      #board-container {
        width: 360px;
        height: 484px;
        min-height: 484px;
      }

      #board {
        grid-template-columns: repeat(6, 40px);
        grid-template-rows: repeat(8, 40px);
        gap: 14px;
      }

      .tile {
        width: 40px;
        height: 40px;
        font-size: 20px;
      }

      #line-canvas {
        position: absolute;
        top: 33px;
        left: 25px;
      }

      #start-modal-container {
        height: 100%;
      }
      #start-modal {
        max-width: 90%;
        padding: 8px;
      }
    }

    @media (max-width: 460px) {
      #heading {
        font-size: 1.1em;
        box-sizing: border-box;
      }
      #help-button {
        right: 12px;
      }
    }
  </style>
</head>
<body>

<div id="start-modal-container" class="popup-modal-container" style="display: flex;">
  <div id="start-modal" class="popup-modal" style="text-align: left;">
    <div id="start-close" class="modal-close" style="display: none;">+</div>
    <div style="font-weight: bold; font-size: 1.5em;">How to Play :</div>
    <div style="font-weight: normal;">
      Select a party color below, your goal is to rig a majority of the map in their favor!<br>
      ‚Ä¢ Drag to connect star tiles into voting districts - connect in any direction, but districts can‚Äôt cross<br>
      ‚Ä¢ Each district must contain the same number of stars (not counting gray), ties create split districts that can help either side<br>
      ‚Ä¢ Win a district by controlling more than half its stars, win the map by controlling more than half its districts<br>
      ‚Ä¢ Tap a district to remove it and try again<br>
      The daily map changes every day but you can play other challenge maps below or make your own!
    </div>
    <br>
    <div style="font-weight: bold; font-size: 1.5em;">What is Gerrymandering?</div>
    <div style="font-weight: normal;">Gerrymandering is a political tactic where those in power redraw voting districts to keep themselves in control -
      manipulating the rules to silence opposition and cling to power. It lets politicians pick their voters,
      instead of voters picking their leaders. By slicing communities apart, they can rig outcomes even when they‚Äôre unpopular.
      This game puts you in their shoes. Can you win <i>without winning fair?</i>
    </div>
    <br>
    <div style="display: flex; gap: 24px;">
      <div id="team-toggle" style="z-index: 25;">
        <label for="team-select" style="color: var(--text);">Team Color:</label>
        <select id="team-select">
          <option value="blue">Blue</option>
          <option value="red">Red</option>
        </select>
      </div>

      <div id="theme-toggle" style="z-index: 25;">
        <label for="theme-select" style="color: var(--text);">Theme:</label>
        <select id="theme-select">
          <option value="system">System</option>
          <option value="light">Light</option>
          <option value="dark">Dark</option>
        </select>
      </div>
    </div>
    <br>
    <div style="display: flex; gap: 24px">
      <a id="show-other-levels" class="leveleditor-line">Show other premade levels</a>
      <a class="leveleditor-line" href="https://ssambender.github.io/GM-GEN/" target="_blank">Try custom level editor</a>
    </div>
    <div id="level-buttons"></div>
    <i>( You can reopen this screen at any time with the <span style="font-weight: 900; padding: 0 2px">?</span> at the top right )</i>

    <div style="display: flex; justify-content: center;">
      <button id="start-game-button">BEGIN</button>
    </div>
  </div>
</div>

<div id="finish-modal-container" class="popup-modal-container" style="display: none; z-index: 21">
  <div id="finish-modal" class="popup-modal">
    <div id="finish-close" class="modal-close">+</div>
    <div id="win-message" style="font-weight: bold; font-size: 1.5em; text-transform: uppercase;">Well Done!</div>
    <div style="font-weight: normal; font-size: 1em; margin: 16px 0; color: var(--text);">FINISHED <span id="map-number-label">0</span> IN <span id="time-spent-label">##:##s</span></div>
    <div id="share-line">Share your time with friends.</div>
  </div>
</div>

<h1 id="heading">
  <div><span style="color: var(--red-letter)">‚òÖ‚òÖ‚òÖ</span> <span id="title-click" title="Reload page.">Gerrymandle</span> <span style="color: var(--blue-letter)">‚òÖ‚òÖ‚òÖ</span></div>
  <div id="help-button">?</div>
</h1>

<h2 id="puzzle-info" style="margin-bottom: 0; color: var(--text);">Daily Map</h2>
<h3 id="puzzle-subinfo" style="margin-top: 0; margin-bottom: 0; font-weight: normal; color: var(--text); text-align: center;"><b style="color: var(--blue-letter)">17</b> - <b style="color: var(--red-letter)">13</b>. Help red win!</h3>
<div id="puzzle-districtbar" style="margin-top: 4px; width: 260px; height: 20px; background: var(--gray-highlight); display: flex; border-radius: 10px; overflow: hidden; margin-bottom: 10px;"></div>
<div id="board-container">
  <canvas id="line-canvas"></canvas>
  <div id="board"></div>
</div>

<div id="timelabel">00:00s</div>

<a id="madebysam" href="https://sambender.net">
  Made with ‚ù§Ô∏è by Sam Bender
</a>

<script>
  // get day number (days since aug 1 2025)
  const startDate = new Date("2025-08-01T00:00:00");
  const today = new Date();
  const diffTime = today - startDate;
  let dayOfMap = Math.floor(diffTime / (1000 * 60 * 60 * 24));
  //document.getElementById('map-number-label').innerText = dayOfMap;

  let shareNameOfMap = "Daily Map" + dayOfMap.toString();  // name to include in share data
  let shareLinkOfMap = "https://ssambender.github.io/gerrymandle/";  // link to include in share data


  // Daily local caches, reset each day:
  let startedDaily = false;  // if true, don't show start modal on page load
  let finishedDaily = false;  // if true, load finished board save and show finish modal instead of start modal on load

  let isPlayingDaily = false;


  // VAR TO HOLD THE LEVEL
  // Fallback level incase todays level gen doesn't work
  let todaysLevel = ["6", "5",
    " ", "R", "B", "O", " ", "O",
    "B", "R", "O", " ", " ", " ",
    "R", "R", "R", "B", " ", " ",
    " ", "B", "R", "R", "B", "R",
    " ", "B", "B", " ", "B", "R",
    "B", "B", "R", "B", "R", "O",
    "O", "B", "R", "B", "B", "B",
    " ", "R", " ", " ", "R", "B"];
  let selectedLevel = todaysLevel;


  // INIT timer
  let elapsedSeconds = 0;
  let timerInterval = null;

  let gameInProgress = false;
  let helpColorWin = 'Red';

  // board params
  const boardCols = 6;
  const boardRows = 8;


  // LEVELS objects database
  const LEVELS = {
    LVL01: ["5", "3",
      " ", " ", " ", " ", " ", " ",
      " ", " ", " ", "O", "R", "R",
      "R", "B", "B", "B", "O", " ",
      " ", "B", "B", " ", "O", " ",
      " ", "R", "O", "B", " ", "B",
      " ", "R", "O", "B", " ", " ",
      " ", " ", "R", "B", "O", " ",
      " ", " ", " ", " ", " ", " "
    ],
    LVL02: ["5", "3",
      " ", " ", " ", " ", " ", " ",
      " ", " ", "B", " ", "B", "B",
      " ", "R", "R", "O", "O", " ",
      " ", "R", "B", "B", " ", " ",
      " ", "R", "R", " ", " ", " ",
      "B", "R", "B", " ", " ", " ",
      " ", "B", "B", " ", " ", " ",
      " ", " ", " ", " ", " ", " "
    ],
    LVL03: ["7", "3",
      " ", " ", " ", " ", " ", " ",
      " ", " ", "B", "B", "B", "B",
      " ", " ", "B", "B", "B", " ",
      " ", "B", "B", "R", "O", "R",
      "R", "R", "R", "B", "B", "R",
      "R", "R", "B", "O", "R", " ",
      " ", "O", "O", " ", " ", " ",
      " ", " ", " ", " ", " ", " "
    ],
    LVL04: ["5", "5",
      " ", "R", "B", "O", " ", " ",
      "R", "B", "R", "B", "O", " ",
      " ", "B", "B", "O", "B", "O",
      " ", "B", "O", "B", "O", "B",
      "B", "B", "B", "R", "B", " ",
      " ", " ", "B", "R", "R", " ",
      " ", "B", "R", "R", "O", "R",
      " ", " ", "R", "O", " ", " "
    ],
    LVL05: ["4", "7",
      "B", "R", " ", "B", "B", "R",
      "R", "B", "R", "R", "R", "B",
      "R", " ", "O", " ", "R", " ",
      "B", " ", "O", "B", "R", "R",
      " ", " ", "B", "R", "R", "B",
      " ", " ", " ", "R", "O", " ",
      " ", " ", "O", "B", "B", "B",
      " ", " ", " ", "B", "B", "B"
    ],
    LVL06: ["5", "5",
      " ", " ", "O", " ", "B", "R",
      " ", " ", " ", " ", "R", "R",
      "B", "B", "B", "B", " ", "B",
      "R", "B", "R", " ", " ", " ",
      "O", "B", "B", "B", "O", "R",
      " ", "O", "R", "B", "R", "B",
      " ", " ", "B", "B", "R", "R",
      " ", "R", " ", "O", " ", "O"
    ],
    LVL07: ["5", "3",
      " ", " ", " ", " ", " ", " ",
      " ", " ", " ", " ", " ", " ",
      "R", "R", "B", "O", " ", " ",
      " ", "B", "B", "B", "B", "R",
      "R", "O", "B", "B", "R", "B",
      "B", " ", "O", "R", " ", " ",
      " ", " ", " ", " ", " ", " ",
      " ", " ", " ", " ", " ", " "
    ],
    LVL08: ["3", "8",
      " ", "R", "B", "B", "B", " ",
      " ", "B", " ", " ", "R", " ",
      " ", "R", " ", " ", "B", " ",
      " ", "B", "R", "B", "B", " ",
      " ", "R", "R", "B", "B", " ",
      " ", "B", " ", " ", "R", " ",
      " ", "B", " ", " ", "R", " ",
      " ", "R", "R", "B", "R", " "
    ],
    LVL09: ["5", "4",
      " ", " ", " ", " ", " ", " ",
      " ", "B", " ", "B", "R", " ",
      "B", " ", "O", "O", "R", "R",
      " ", "O", "B", "B", " ", "O",
      " ", "B", "R", "B", "B", "O",
      "R", "O", "R", "R", "B", "R",
      " ", " ", "B", "R", "B", " ",
      " ", " ", " ", " ", " ", " "
    ],
    LVL10: ["5", "3",
      " ", " ", " ", " ", " ", " ",
      " ", " ", " ", "O", "B", "B",
      "O", "O", "O", "B", "O", "B",
      "B", "R", "R", "B", "O", "O",
      "R", " ", "B", " ", "O", "R",
      " ", " ", " ", "B", "R", "O",
      " ", " ", " ", " ", "R", "B",
      " ", " ", " ", " ", " ", " "
    ],
    LVL11: ["5", "5",
      " ", " ", " ", " ", "B", "B",
      " ", " ", " ", "R", "B", "O",
      "B", "R", "R", "B", "B", " ",
      " ", " ", "O", " ", "B", "R",
      "R", "B", "B", " ", "B", "B",
      " ", " ", "B", " ", "R", "R",
      " ", " ", " ", "R", "R", "B",
      " ", " ", " ", "R", "B", "B"
    ],
    LVL12: ["5", "6",
      " ", "R", " ", "B", "B", " ",
      "R", "B", "B", "R", "B", "R",
      "B", "R", "B", "B", "R", " ",
      " ", "B", "R", "B", "O", "B",
      "R", "O", "R", "B", "B", " ",
      "R", "B", "R", " ", "R", "B",
      " ", "R", "B", "B", "O", " ",
      " ", " ", " ", " ", " ", " "
    ],
    LVL13: ["4", "7",
      "O", "B", "B", "B", "B", "R",
      " ", " ", " ", "B", "B", "O",
      " ", " ", "R", "B", "R", "B",
      " ", " ", " ", "B", "R", "R",
      "O", "O", "O", "O", " ", " ",
      " ", "B", "R", "B", "R", "R",
      "B", "R", "O", "R", "B", "B",
      "R", "R", "B", "R", " ", " "
    ],
    JELLYFISH: ["3", "3",
      " ", " ", "B", "O", " ", " ",
      " ", "O", "O", " ", "O", "B",
      "O", "R", " ", "O", " ", "O",
      "O", " ", " ", " ", "O", "O",
      "B", "R", " ", " ", "O", "B",
      " ", " ", "O", " ", "O", " ",
      " ", " ", "O", " ", "O", " ",
      "R", "B", " ", " ", " ", "R"
    ],
    BRIDGE: ["5", "5",
      " ", "B", "B", "R", "B", "R",
      "R", "R", "R", " ", " ", " ",
      "B", "O", " ", " ", "R", "O",
      "R", "O", " ", "B", "B", " ",
      "R", "B", "B", "B", "R", "O",
      "R", " ", " ", "B", " ", "O",
      "B", " ", " ", "B", "B", "B",
      " ", "O", "O", "O", " ", "R"
    ],
    SAMO: ["4", "7",
      "B", "R", "B", " ", " ", " ",
      " ", " ", "R", "B", " ", " ",
      "O", " ", " ", "R", " ", " ",
      "R", "R", "B", "R", " ", " ",
      "R", "O", "B", "B", "B", "O",
      "O", "R", "B", "R", "B", "R",
      " ", "B", "R", "R", "B", "B",
      " ", " ", "B", "R", "B", "B"
    ],
    LVL14: ["6", "5",
      "B", "R", " ", "B", "B", "R",
      "B", "R", "O", " ", "B", "B",
      "R", "R", " ", "R", "B", "R",
      "R", "B", "O", " ", "R", "B",
      "B", "R", " ", "O", "B", "B",
      " ", "O", " ", "O", "R", "B",
      "O", " ", " ", "R", "B", "B",
      "O", "O", "O", "R", "B", "R"
    ],
    HALFSIES: ["6", "8",
      "R", "R", "R", "B", "B", "B",
      "R", "R", "R", "B", "B", "B",
      "R", "R", "R", "B", "B", "B",
      "R", "R", "B", "B", "B", "B",
      "R", "R", "B", "B", "B", "B",
      "R", "R", "R", "B", "B", "B",
      "R", "R", "R", "B", "B", "B",
      "R", "R", "R", "B", "B", "B",
    ],
  };


  // convert css vars to non-variable codes
  const styleVars = getComputedStyle(document.documentElement);


  // create one button for each level object in levels database - not permanent
  function generateLevelButtons() {
    const container = document.getElementById("level-buttons");
    for (const key in LEVELS) {
      const btn = document.createElement("button");
      btn.innerText = key;
      btn.onclick = () => {
        selectedLevel = LEVELS[key];  // so the "start" button uses this if clicked later
        starterFunc();
        loadLevel(key);
      };
      container.appendChild(btn);
    }
  }
  generateLevelButtons();


  let currentDistrictCount = 0;
  let currentVoteCount = 0;
  let levelData = [];
  let finalizedDistricts = [];


  // CHARACTER SYMBOLS TO DISPLAY
  // ‚òÖ‚úØ‚ú©‚ú∞   ‚ú™   ‚ú¶‚úß   R üü• B üü¶ W ‚¨ú
  function getDisplayCharacter(char) {
    if (helpColorWin === "red") {
      switch (char) {
        case "R": return "‚òÖ";
        case "B": return "‚ú™";
        case "O": return "‚ú©";
        default: return " ";
      }
    }
    else {
      switch (char) {
        case "R": return "‚ú™";
        case "B": return "‚òÖ";
        case "O": return "‚ú©";
        default: return " ";
      }
    }
  }


  // LOAD TILES ON BOARD - Premade challenge levels
  function loadLevel(levelName) {
    if (!LEVELS[levelName]) return;

    board.style.pointerEvents = "auto";

    // Reset timer on level load
    stopTimer();
    elapsedSeconds = 0;
    updateDisplay();
    startTimer();

    const data = LEVELS[levelName];

    currentDistrictCount = parseInt(data[0]);
    currentVoteCount = parseInt(data[1]);

    // Update levelData
    levelData.length = 0;
    levelData.push(...data);

    // Clear previous state
    finalizedDistricts = [];
    board.innerHTML = "";
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // Rebuild board
    let index = 2; // skip the first two (district x vote var counts)
    for (let row = 0; row < boardRows; row++) {
      for (let col = 0; col < boardCols; col++) {
        const tile = document.createElement("div");
        tile.classList.add("tile");

        const letter = data[index] || "";
        //tile.dataset.value = letter;
        tile.dataset.value = letter; // store actual value for logic
        tile.innerText = getDisplayCharacter(letter); // show visual representation
        if (letter === "B") {
          //tile.style.color = styleVars.getPropertyValue('--blue-letter').trim();
          if (helpColorWin === "red") {
            tile.classList.add("tile-blue");
          }
          else {
            tile.classList.add("tile-red");
          }
          tile.style.cursor = "pointer";
        }
        if (letter === "R") {
          //tile.style.color = styleVars.getPropertyValue('--red-letter').trim();
          if (helpColorWin === "red") {
            tile.classList.add("tile-red");
          }
          else {
            tile.classList.add("tile-blue");
          }
          tile.style.cursor = "pointer";
        }
        if (letter === "O") {
          //tile.style.color = styleVars.getPropertyValue('--gray-letter').trim();
          tile.classList.add("tile-gray");
          tile.style.cursor = "pointer";
        }

        tile.dataset.row = row;
        tile.dataset.col = col;

        tile.addEventListener("click", () => {
          if (isTileFinalized(tile)) {
            removeDistrictContainingTile(tile);
            drawLines();
          }
        });

        board.appendChild(tile);
        index++;
      }
    }

    //setInfo();
    document.getElementById('puzzle-info').innerText = `Challenge Map ${levelName}`;
    document.getElementById('map-number-label').innerText = `CHALLENGE MAP ${levelName.toUpperCase()}`;  //  #${dayOfMap}

    shareNameOfMap = `Challenge Map '${levelName}'`;
    shareLinkOfMap = "https://ssambender.github.io/gerrymandle/?level=" + levelName;

    updateVoteTotals();
    updateDistrictBar();
    resizeCanvas();
  }
  // LOAD TILES FROM ARRAY - Daily level and custom url param levels
  function loadLevelArray(levelArray) {
    board.style.pointerEvents = "auto";

    // Reset timer on level load
    stopTimer();
    elapsedSeconds = 0;
    updateDisplay();
    startTimer();

    const data = levelArray;

    currentDistrictCount = parseInt(data[0]);
    currentVoteCount = parseInt(data[1]);

    // Update levelData
    levelData.length = 0;
    levelData.push(...data);

    // Clear previous state
    finalizedDistricts = [];
    board.innerHTML = "";
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // Rebuild board
    let index = 2;
    for (let row = 0; row < boardRows; row++) {
      for (let col = 0; col < boardCols; col++) {
        const tile = document.createElement("div");
        tile.classList.add("tile");

        const letter = data[index] || "";
        tile.dataset.value = letter;
        tile.innerText = getDisplayCharacter(letter);

        if (letter === "B") {
          tile.classList.add(helpColorWin === "red" ? "tile-blue" : "tile-red");
          tile.style.cursor = "pointer";
        }
        if (letter === "R") {
          tile.classList.add(helpColorWin === "red" ? "tile-red" : "tile-blue");
          tile.style.cursor = "pointer";
        }
        if (letter === "O") {
          tile.classList.add("tile-gray");
          tile.style.cursor = "pointer";
        }

        tile.dataset.row = row;
        tile.dataset.col = col;

        tile.addEventListener("click", () => {
          if (isTileFinalized(tile)) {
            removeDistrictContainingTile(tile);
            drawLines();
          }
        });

        board.appendChild(tile);
        index++;
      }
    }

    //setInfo();
    updateVoteTotals();
    updateDistrictBar();
    resizeCanvas();
  }



  // todo - if NOT startedDaily, generate:
  // CREATE LEVEL FROM SEED
  function generateRandomMapFromSeed(seedText) {
    const rows = 8, cols = 6;
    const combos = [ [5,6], [6,5], [7,3], [4,7], [3,8], [6,4], [5,5], [5,3], [5,4] ];

    function sha256(text) {
      const utf8 = new TextEncoder().encode(text);
      return crypto.subtle.digest("SHA-256", utf8).then(buf => {
        return Array.from(new Uint8Array(buf)).map(b => b.toString(16).padStart(2, "0")).join("");
      });
    }

    function mulberry32(seed) {
      return function () {
        seed |= 0; seed = seed + 0x6D2B79F5 | 0;
        let t = Math.imul(seed ^ seed >>> 15, 1 | seed);
        t = t + Math.imul(t ^ t >>> 7, 61 | t) ^ t;
        return ((t ^ t >>> 14) >>> 0) / 4294967296;
      };
    }

    function numberToSuffix(n) {
      let s = '';
      while (n >= 0) {
        s = String.fromCharCode((n % 26) + 97) + s;
        n = Math.floor(n / 26) - 1;
      }
      return s;
    }

    function shuffle(array, rand) {
      for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(rand() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
      }
    }

    function getNeighbors(r, c, used) {
      return [[r-1,c], [r+1,c], [r,c-1], [r,c+1]].filter(
              ([nr,nc]) => nr >= 0 && nr < rows && nc >= 0 && nc < cols && !used[nr][nc]
      );
    }

    function generateWinnableLevel(districtCount, voteCount, rand) {
      const grid = Array.from({ length: rows }, () => Array(cols).fill(" "));
      const used = Array.from({ length: rows }, () => Array(cols).fill(false));
      const districts = [];

      function placeDistrict() {
        let attempts = 0;
        while (attempts++ < 3000) {
          const startR = Math.floor(rand() * rows);
          const startC = Math.floor(rand() * cols);
          if (used[startR][startC]) continue;
          const queue = [[[startR, startC]]];
          while (queue.length) {
            const path = queue.shift();
            if (path.length >= voteCount) {
              const finalPath = path.slice(0, voteCount);
              finalPath.forEach(([r, c]) => used[r][c] = true);
              const oTiles = [];
              for (let i = voteCount; i < Math.min(path.length, voteCount + 2); i++) {
                const [r, c] = path[i];
                if (!used[r][c]) {
                  used[r][c] = true;
                  oTiles.push([r, c]);
                }
              }
              districts.push({ path: finalPath, oTiles, votes: [] });
              return true;
            }
            const [lr, lc] = path[path.length - 1];
            const neighbors = getNeighbors(lr, lc, used).filter(
                    ([nr, nc]) => !path.some(([pr, pc]) => pr === nr && pc === nc)
            );
            shuffle(neighbors, rand);
            neighbors.forEach(n => queue.push([...path, n]));
          }
        }
        return false;
      }

      for (let i = 0; i < districtCount; i++) {
        if (!placeDistrict()) return null;
      }

      let redWins = 0, blueWins = 0, redTiles = 0, blueTiles = 0;

      for (const dist of districts) {
        let r = 0, b = 0;
        const votes = [];
        for (let i = 0; i < dist.path.length; i++) {
          const vote = rand() < 0.48 ? 'R' : 'B';
          vote === 'R' ? r++ : b++;
          votes.push(vote);
        }
        if (r <= b) {
          for (let i = 0; i < votes.length; i++) {
            if (votes[i] === 'B') {
              votes[i] = 'R';
              r++; b--;
              break;
            }
          }
        }
        dist.votes = votes;
        redTiles += r;
        blueTiles += b;
        if (r > b) redWins++;
        else if (b > r) blueWins++;
      }

      if (redWins <= blueWins || redTiles >= blueTiles) return null;

      for (const dist of districts) {
        dist.path.forEach(([r, c], i) => grid[r][c] = dist.votes[i]);
        dist.oTiles.forEach(([r, c]) => grid[r][c] = 'O');
      }

      for (let r = 0; r < rows; r++) {
        for (let c = 0; c < cols; c++) {
          if (grid[r][c] === ' ') grid[r][c] = rand() < 0.3 ? 'O' : ' ';
        }
      }

      return [districtCount.toString(), voteCount.toString(), ...grid.flat()];
    }

    return new Promise(async (resolve) => {
      let attempt = 0;
      while (true) {
        const suffix = attempt === 0 ? '' : numberToSuffix(attempt - 1);
        const fullSeed = seedText + suffix;
        const hash = await sha256(fullSeed);
        const seed = parseInt(hash.slice(0, 8), 16);
        const rand = mulberry32(seed);
        const comboIndex = parseInt(hash.slice(8, 10), 16) % combos.length;
        const [groupCount, groupSize] = combos[comboIndex];

        const level = generateWinnableLevel(groupCount, groupSize, rand);
        if (level) return resolve(level);
        attempt++;
      }
    });
  }



  // init and state vars
  const board = document.getElementById("board");
  const canvas = document.getElementById("line-canvas");
  const ctx = canvas.getContext("2d");
  let isMouseDown = false;
  let path = [];


  // redraw canvas
  function resizeCanvas() {
    const container = document.getElementById("board-container");

    const width = container.offsetWidth;
    const height = container.offsetHeight;

    canvas.width = width;
    canvas.height = height;

    canvas.style.width = width + "px";
    canvas.style.height = height + "px";

    drawLines(); // redraw after resize
  }
  resizeCanvas();


  // update the info - title
  function setInfo() {
    document.getElementById('puzzle-info').innerText = `Daily Map ${today.getMonth()+1}/${today.getDate()}/${today.getFullYear()}`;  //  #${dayOfMap}
    document.getElementById('map-number-label').innerText = `DAILY MAP ${today.getMonth()+1}/${today.getDate()}/${today.getFullYear()}`;  //  #${dayOfMap}
    shareNameOfMap = `Daily Map ${today.getMonth()+1}/${today.getDate()}/${today.getFullYear()}`;
    shareLinkOfMap = "https://ssambender.github.io/gerrymandle/";
  }

  // update the subinfo line - blue & red star count
  function updateVoteTotals() {
    const rTotal = levelData.filter(cell => cell === "R").length;
    const bTotal = levelData.filter(cell => cell === "B").length;

    const subInfo = document.getElementById('puzzle-subinfo');
    if (helpColorWin === "red") {
      subInfo.innerHTML = `${currentDistrictCount} districts of ${currentVoteCount}.<br><b style="color: #5988d1">${bTotal}</b> - <b style="color: #e05353">${rTotal}</b>. Help <b>${helpColorWin}</b> win!`;
    }
    else {
      subInfo.innerHTML = `${currentDistrictCount} districts of ${currentVoteCount}.<br><b style="color: #e05353">${bTotal}</b> - <b style="color: #5988d1">${rTotal}</b>. Help <b>${helpColorWin}</b> win!`;
    }
  }
  setInfo();
  updateVoteTotals();


  // update the district percent indicator bar
  function updateDistrictBar() {
    const bar = document.getElementById("puzzle-districtbar");

    const styleVars = getComputedStyle(document.documentElement);
    const total = currentDistrictCount;
    let red = 0, blue = 0, purple = 0;

    finalizedDistricts.forEach(d => {
      if (d.colorClass === "selected-red") red++;
      else if (d.colorClass === "selected-blue") blue++;
      else if (d.colorClass === "selected-purple") purple++;
    });

    const remaining = total - red - blue - purple;

    const segments = [
      { key: "red", count: red, color: styleVars.getPropertyValue('--red-highlight').trim() },
      { key: "blue", count: blue, color: styleVars.getPropertyValue('--blue-highlight').trim() },
      { key: "purple", count: purple, color: styleVars.getPropertyValue('--purple-highlight').trim() },
      { key: "gray", count: remaining, color: styleVars.getPropertyValue('--gray-highlight').trim() }
    ];

    // Update or create segments
    segments.forEach((seg, i) => {
      let segment = bar.children[i];
      const desiredWidth = `${(seg.count / total) * 100}%`;

      if (!segment) {
        // New segment
        segment = document.createElement("div");
        segment.className = "district-segment";
        segment.style.background = seg.color;
        segment.style.width = "0";
        // segment.title = desiredWidth;
        bar.appendChild(segment);
        requestAnimationFrame(() => {
          segment.style.width = desiredWidth;
        });
      } else {
        // Existing segment: update color & width only if changed
        if (segment.style.background !== seg.color) {
          segment.style.background = seg.color;
        }
        if (segment.style.width !== desiredWidth) {
          segment.style.width = desiredWidth;
        }
      }
    });

    // Remove extra segments if any
    while (bar.children.length > segments.length) {
      bar.removeChild(bar.lastChild);
    }
  }


  // helper func for line drawing
  function getTileCenter(tile) {
    const rect = tile.getBoundingClientRect();
    const parentRect = board.getBoundingClientRect();
    return {
      x: rect.left - parentRect.left + rect.width / 2,
      y: rect.top - parentRect.top + rect.height / 2
    };
  }


  // Draw lines connecting tiles for given path with specified color and line width
  function drawPathLines(pathTiles, color, lineWidth = 16) {
    if (pathTiles.length < 2) return;
    ctx.strokeStyle = color;
    ctx.lineWidth = lineWidth;
    ctx.lineCap = "round";
    ctx.beginPath();
    const start = getTileCenter(pathTiles[0]);
    ctx.moveTo(start.x, start.y);
    for (let i = 1; i < pathTiles.length; i++) {
      const point = getTileCenter(pathTiles[i]);
      ctx.lineTo(point.x, point.y);
    }
    ctx.stroke();
  }


  // update connecting line colors
  function updateCurrentPathColors() {
    if (path.length === 0) return;

    const votes = path.map(t => t.dataset.value);
    const rCount = votes.filter(v => v === "R").length;
    const bCount = votes.filter(v => v === "B").length;

    // Remove all color classes first
    path.forEach(t => {
      t.classList.remove("selected", "selected-red", "selected-blue", "selected-purple");
    });

    const voteCount = path.filter(t => {
      const val = t.dataset.value.trim();
      return val === "R" || val === "B";
    }).length;

    if (voteCount >= currentVoteCount) {
      // Apply matching color class
      if (helpColorWin === "red") {
        if (rCount > bCount) {
          path.forEach(t => t.classList.add("selected-red"));
        } else if (bCount > rCount) {
          path.forEach(t => t.classList.add("selected-blue"));
        } else {
          path.forEach(t => t.classList.add("selected-purple"));
        }
      }
      else {
        if (bCount > rCount) {
          path.forEach(t => t.classList.add("selected-red"));
        } else if (rCount > bCount) {
          path.forEach(t => t.classList.add("selected-blue"));
        } else {
          path.forEach(t => t.classList.add("selected-purple"));
        }
      }
    } else {
      // Not full length apply default selected bg
      path.forEach(t => t.classList.add("selected"));
    }
  }


  // draws all finalized districts lines plus current drawing path line
  function drawLines() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // Draw finalized districts lines first
    finalizedDistricts.forEach(district => {
      const color = getStrokeColorForClass(district.colorClass);
      drawPathLines(district.tiles, color);
    });

    // Draw current path line if any
    if (path.length < 2) return;

    const voteCount = path.filter(t => {
      const val = t.dataset.value.trim();
      return val === "R" || val === "B";
    }).length;

    if (voteCount >= currentVoteCount) {
      const strokeColor = finalizePathColor();
      drawPathLines(path, strokeColor);
    } else {
      const gray = styleVars.getPropertyValue('--gray-highlight').trim();
      drawPathLines(path, gray);
    }

  }


  // get stroke color string for given tile class
  function getStrokeColorForClass(colorClass) {
    switch (colorClass) {
      case "selected-red": return styleVars.getPropertyValue('--red-highlight').trim();
      case "selected-blue": return styleVars.getPropertyValue('--blue-highlight').trim();
      case "selected-purple": return styleVars.getPropertyValue('--purple-highlight').trim();
      default: return styleVars.getPropertyValue('--gray-highlight').trim();
    }
  }


  // check if tiles are adjacent on grid
  function areAdjacent(tile1, tile2) {
    const r1 = +tile1.dataset.row;
    const c1 = +tile1.dataset.col;
    const r2 = +tile2.dataset.row;
    const c2 = +tile2.dataset.col;

    const rowDiff = r2 - r1;
    const colDiff = c2 - c1;

    const absRow = Math.abs(rowDiff);
    const absCol = Math.abs(colDiff);

    if (absRow > 1 || absCol > 1 || (absRow === 0 && absCol === 0)) return false;

    // Diagonal move
    if (absRow === 1 && absCol === 1) {
      const midTileA = document.querySelector(`[data-row="${r1}"][data-col="${c2}"]`);
      const midTileB = document.querySelector(`[data-row="${r2}"][data-col="${c1}"]`);

      // Check if either of the mid-tiles are connected by a finalized district
      for (const district of finalizedDistricts) {
        if (
                midTileA && midTileB &&
                district.tiles.includes(midTileA) &&
                district.tiles.includes(midTileB)
        ) {
          // They're both in a district ‚Äî check if they're directly connected
          const idxA = district.tiles.indexOf(midTileA);
          const idxB = district.tiles.indexOf(midTileB);
          if (Math.abs(idxA - idxB) === 1) {
            return false; // A connector exists ‚Äî block diagonal
          }
        }
      }
    }

    return true;
  }



  // REMOVE AN EXISTING DISTRICT
  // clear the path
  function clearPath() {
    path.forEach(t => {
      if (!isTileFinalized(t)) {
        t.classList.remove("selected", "selected-red", "selected-blue", "selected-purple");
      }
    });
    path = [];
    drawLines();
  }

  // check tiles
  function isTileFinalized(tile) {
    return finalizedDistricts.some(district => district.tiles.includes(tile));
  }

  // get tile and connected tiles to remove
  function removeDistrictContainingTile(tile) {
    for (let i = 0; i < finalizedDistricts.length; i++) {
      const district = finalizedDistricts[i];
      if (district.tiles.includes(tile)) {
        // Log what color district is removed
        let colorName = "purple";
        if (district.colorClass === "selected-red") colorName = "red";
        else if (district.colorClass === "selected-blue") colorName = "blue";
        console.log(`${colorName} district removed`);

        district.tiles.forEach(t => {
          t.classList.remove("selected-red", "selected-blue", "selected-purple");
        });
        finalizedDistricts.splice(i, 1);

        // Log updated totals
        let redCount = 0, blueCount = 0, purpleCount = 0;
        finalizedDistricts.forEach(d => {
          if (d.colorClass === "selected-red") redCount++;
          else if (d.colorClass === "selected-blue") blueCount++;
          else if (d.colorClass === "selected-purple") purpleCount++;
        });
        console.log(`total red: ${redCount}, total blue: ${blueCount}, total purple: ${purpleCount}`);

        updateDistrictBar();

        break;
      }
    }
  }



  // SHARE DATA AND SHARE LINK
  let timeSpentString = "0";
  let shareData = {
    title: 'Gerrymandle #' + dayOfMap,
    text: `üî∏I beat ${shareNameOfMap} in ${timeSpentString}. üó∫Ô∏è \nüîπThink you can solve it faster?\n${shareLinkOfMap}`,
    //url: 'https://ssambender.github.io/gerrymandle/'
  }
  let sharelink = document.getElementById('share-line');
  sharelink.addEventListener('click', async (event) => {
    event.preventDefault();

    // Update the share text with the latest time string
    shareData.text = `üî∏I beat ${shareNameOfMap} in ${timeSpentString}. üó∫Ô∏è\nüîπThink you can solve it faster?\n${shareLinkOfMap}`;

    try {
      await navigator.share(shareData);
      console.log('shared successfully');
    } catch (err) {
      console.log('error: ' + err);
    }
  }, false);



  // EVENT LISTENERS
  // mouse down
  board.addEventListener("mousedown", (e) => {
    if (!e.target.classList.contains("tile")) return;
    if (isTileFinalized(e.target)) return;
    if (e.target.dataset.value.trim() === "") return;  //prevents selecting blank spaces

    clearPath();
    isMouseDown = true;

    path.push(e.target);
    updateCurrentPathColors();
    drawLines();

    e.target.classList.add("pop");
    e.target.addEventListener("animationend", () => {
      e.target.classList.remove("pop");
    }, { once: true });
  });
  // touch down
  board.addEventListener("touchstart", (e) => {
    const touch = e.touches[0];
    const target = document.elementFromPoint(touch.clientX, touch.clientY);
    if (!target || !target.classList.contains("tile")) return;
    if (isTileFinalized(target)) return;
    if (target.dataset.value.trim() === "") return;

    clearPath();
    isMouseDown = true;

    path.push(target);
    updateCurrentPathColors();
    drawLines();

    target.classList.add("pop");
    target.addEventListener("animationend", () => {
      target.classList.remove("pop");
    }, { once: true });

    e.preventDefault();
  }, { passive: false });

  // mouse drag
  board.addEventListener("mouseover", (e) => {
    if (!isMouseDown || !e.target.classList.contains("tile")) return;
    if (isTileFinalized(e.target)) return;

    const currentTile = e.target;
    if (currentTile.dataset.value.trim() === "") return;  //prevents selecting blank spaces

    const last = path[path.length - 1];
    const secondLast = path[path.length - 2];

    // Allow retreating
    if (secondLast === currentTile) {
      const removed = path.pop();
      removed.classList.remove("selected", "selected-red", "selected-blue", "selected-purple");
      updateCurrentPathColors();
      drawLines();
      return;
    }

    const voteCount = path.filter(t => {
      const val = t.dataset.value.trim();
      return val === "R" || val === "B";
    }).length;

    const atLimit = voteCount >= currentVoteCount;

    if (atLimit) return;

    if (!path.includes(currentTile) && areAdjacent(last, currentTile)) {
      path.push(currentTile);
      updateCurrentPathColors();
      drawLines();

      currentTile.classList.add("pop");
      currentTile.addEventListener("animationend", () => {
        currentTile.classList.remove("pop");
      }, { once: true });
    }
  });
  // touch drag
  board.addEventListener("touchmove", (e) => {
    if (!isMouseDown) return;

    const touch = e.touches[0];
    const target = document.elementFromPoint(touch.clientX, touch.clientY);
    if (!target || !target.classList.contains("tile")) return;
    if (isTileFinalized(target)) return;
    if (target.dataset.value.trim() === "") return;

    const last = path[path.length - 1];
    const secondLast = path[path.length - 2];

    if (secondLast === target) {
      const removed = path.pop();
      removed.classList.remove("selected", "selected-red", "selected-blue", "selected-purple");
      updateCurrentPathColors();
      drawLines();
      return;
    }

    const voteCount = path.filter(t => ["R", "B"].includes(t.dataset.value)).length;
    const atLimit = voteCount >= currentVoteCount;

    if (atLimit) return;

    if (!path.includes(target) && areAdjacent(last, target)) {
      path.push(target);
      updateCurrentPathColors();
      drawLines();

      target.classList.add("pop");
      target.addEventListener("animationend", () => {
        target.classList.remove("pop");
      }, { once: true });
    }

    e.preventDefault();
  }, { passive: false });

  // mouse up
  window.addEventListener("mouseup", () => {
    if (path.length > 0) {
      const word = path.map(t => t.dataset.value).join("");
      // console.log("Selected word:", word);

      const voteCount = path.filter(t => {
        const val = t.dataset.value.trim();
        return val === "R" || val === "B";
      }).length;

      if (voteCount === currentVoteCount) {
        // Finalize district
        const colorClass = getFinalColorClass();

        finalizedDistricts.push({
          tiles: [...path],
          colorClass
        });

        // remove temp selected class and apply final color class only
        path.forEach(t => {
          t.classList.remove("selected");
          t.classList.add(colorClass);
        });

        // log district color drawn
        let colorName = "purple";
        if (colorClass === "selected-red") colorName = "red";
        else if (colorClass === "selected-blue") colorName = "blue";
        console.log(`${colorName} district drawn`);

        // Count totals
        let redCount = 0, blueCount = 0, purpleCount = 0;
        finalizedDistricts.forEach(district => {
          if (district.colorClass === "selected-red") redCount++;
          else if (district.colorClass === "selected-blue") blueCount++;
          else if (district.colorClass === "selected-purple") purpleCount++;
        });
        console.log(`total red: ${redCount}, total blue: ${blueCount}, total purple: ${purpleCount}`);

        updateDistrictBar();

        if (finalizedDistricts.length === currentDistrictCount) {
          console.log("all districts drawn");
          if ((helpColorWin === "red" && redCount > blueCount) || (helpColorWin === "blue" && redCount < blueCount)) {
            console.log("LEVEL WIN!");
            console.log("Well Done!");
            stopTimer();

            if (isPlayingDaily) {
              finishedDaily = true;
              console.log("FINISHED DAILY");
            }

            const minutes = String(Math.floor(elapsedSeconds / 60)).padStart(2, '0');
            const seconds = String(elapsedSeconds % 60).padStart(2, '0');
            document.getElementById('time-spent-label').innerText = `${minutes}:${seconds}s`;

            // share data timer
            if ( Math.floor(elapsedSeconds / 60) < 1 ) {
              timeSpentString = `${String(elapsedSeconds % 60)}s`;
            }
            else {
              timeSpentString = `${String(Math.floor(elapsedSeconds / 60))}m ${String(elapsedSeconds % 60)}s`;
            }

            board.style.pointerEvents = "none";  // stop board edits after win
            //board.style.pointerEvents = "auto";  // to reenable events on board reset or something

            document.querySelectorAll('.tile').forEach(tile => {
              const row = parseInt(tile.dataset.row);
              const col = parseInt(tile.dataset.col);
              const delay = (row * boardCols + col) * 15;
              setTimeout(() => {
                tile.classList.add('fade-text');
              }, delay);
            });

            document.getElementById('finish-modal-container').style.display = 'flex';
            document.getElementById('finish-modal-container').style.opacity = '0';
            setTimeout(() => {
              document.getElementById('finish-modal-container').style.display = 'flex';
              document.getElementById('finish-modal-container').style.opacity = '1';
            }, 1500);
          }
          else {
            console.log("NOT QUITE!");
          }
        }

        path = [];
        drawLines();
      } else {
        clearPath();
      }
    }
    isMouseDown = false;
  });
  // touch up - if error: change board to window for touchend below
  board.addEventListener("touchend", (e) => {
    if (path.length === 0) return;

    e.preventDefault();
    isMouseDown = false;

    const voteTiles = path.filter(t => ["R", "B"].includes(t.dataset.value.trim()));
    const voteCount = voteTiles.length;

    if (voteCount === currentVoteCount && path.length >= voteCount) {
      const colorClass = getFinalColorClass();

      finalizedDistricts.push({
        tiles: [...path],
        colorClass
      });

      path.forEach(t => {
        t.classList.remove("selected");
        t.classList.add(colorClass);
      });

      updateDistrictBar();

      // Win check logic
      const redCount = finalizedDistricts.filter(d => d.colorClass === "selected-red").length;
      const blueCount = finalizedDistricts.filter(d => d.colorClass === "selected-blue").length;

      if (finalizedDistricts.length === currentDistrictCount) {
        if ((helpColorWin === "red" && redCount > blueCount) ||
                (helpColorWin === "blue" && blueCount > redCount)) {
          console.log("LEVEL WIN!");
          stopTimer();

          const minutes = String(Math.floor(elapsedSeconds / 60)).padStart(2, '0');
          const seconds = String(elapsedSeconds % 60).padStart(2, '0');
          document.getElementById('time-spent-label').innerText = `${minutes}:${seconds}s`;

          // share data timer
          if ( Math.floor(elapsedSeconds / 60) < 1 ) {
            timeSpentString = `${String(elapsedSeconds % 60)}s`;
          }
          else {
            timeSpentString = `${String(Math.floor(elapsedSeconds / 60))}m ${String(elapsedSeconds % 60)}s`;
          }

          board.style.pointerEvents = "none";  // stop board edits after win

          document.querySelectorAll('.tile').forEach(tile => {
            const row = parseInt(tile.dataset.row);
            const col = parseInt(tile.dataset.col);
            const delay = (row * boardCols + col) * 15;
            setTimeout(() => {
              tile.classList.add('fade-text');
            }, delay);
          });

          document.getElementById('finish-modal-container').style.display = 'flex';
          document.getElementById('finish-modal-container').style.opacity = '0';
          setTimeout(() => {
            document.getElementById('finish-modal-container').style.display = 'flex';
            document.getElementById('finish-modal-container').style.opacity = '1';
          }, 1500);
        }
      }

      path = [];
      drawLines();
    } else {
      clearPath();
    }
  }, { passive: false });

  // detect mouse leave
  window.addEventListener("mouseleave", () => {
    isMouseDown = false;
  });

  // detect window resize
  window.addEventListener("resize", () => {
    resizeCanvas();
    drawLines();
  });



  // FINALIZE DISTRICT COORS
  function getFinalColorClass() {
    const votes = path
            .map(t => t.dataset.value)
            .filter(v => v !== "O");
    const rCount = votes.filter(v => v === "R").length;
    const bCount = votes.filter(v => v === "B").length;

    if (helpColorWin === "red") {
      if (rCount > bCount) return "selected-red";
      else if (bCount > rCount) return "selected-blue";
      else return "selected-purple";
    }
    else {
      if (rCount > bCount) return "selected-blue";
      else if (bCount > rCount) return "selected-red";
      else return "selected-purple";
    }
  }
  function finalizePathColor() {
    const votes = path
            .map(t => t.dataset.value)
            .filter(v => v !== "O");
    const rCount = votes.filter(v => v === "R").length;
    const bCount = votes.filter(v => v === "B").length;

    if (helpColorWin === "red") {
      if (rCount > bCount) return styleVars.getPropertyValue('--red-highlight').trim();
      else if (bCount > rCount) return styleVars.getPropertyValue('--blue-highlight').trim();
      else return styleVars.getPropertyValue('--purple-highlight').trim();
    }
    else {
      if (rCount > bCount) return styleVars.getPropertyValue('--blue-highlight').trim();
      else if (bCount > rCount) return styleVars.getPropertyValue('--red-highlight').trim();
      else return styleVars.getPropertyValue('--purple-highlight').trim();
    }
  }



  // START AND FINISH MODALS
  // close win modal
  document.getElementById('finish-close').addEventListener("click", () => {
    document.getElementById('finish-modal-container').style.display = 'none';
    document.getElementById('finish-modal-container').style.opacity = '0';
  });

  function starterFunc() {
    document.getElementById('start-modal-container').style.display = 'none';
    document.getElementById('start-modal-container').style.opacity = '0';

    // START LEVEL
    startTimer();

    document.body.scrollTop = document.documentElement.scrollTop = 0;

    gameInProgress = true;
    document.getElementById('team-select').disabled = true;
    if (document.getElementById('team-select').value === "red") {
      helpColorWin = "red";
    }
    else {
      helpColorWin = "blue";
    }
    updateVoteTotals();
    //loadLevel('LVL01');
    loadLevelArray(selectedLevel);

    document.body.style.overflowY = 'visible';
    document.getElementById('start-game-button').style.display = 'none';
    document.getElementById('start-modal').style.padding = '48px';
    document.getElementById('start-close').style.display = 'flex';

    document.getElementById('help-button').style.visibility = 'visible';
    document.getElementById('help-button').style.pointerEvents = 'all';
  }
  // start modal - BEGIN button pressed - begin game start game
  document.getElementById('start-game-button').addEventListener("click", () => {
    console.log("STARTED DAILY");
    startedDaily = true;
    isPlayingDaily = true;
    starterFunc();
  })

  // close help modal
  document.getElementById('start-close').addEventListener("click", () => {
    document.getElementById('start-modal-container').style.display = 'none';
    document.getElementById('start-modal-container').style.opacity = '0';
  });

  // open help modal
  document.getElementById('help-button').addEventListener("click", () => {
    document.getElementById('start-modal-container').style.display = 'flex';
    document.getElementById('start-modal-container').style.opacity = '1';
    document.getElementById('start-modal-container').style.background = 'var(--bg-opacity)';
  });

  // prevent flicker on pageload (when selected theme and system theme don't match)
  setTimeout(() => {
    document.getElementById('start-game-button').style.transition = "color .15s, border .15s";
  }, 200);



  // LIGHT/DARK THEME
  const themeSelect = document.getElementById("theme-select");

  // auto check theme preference
  window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', (e) => {
    console.log("Color scheme changed:", e.matches ? "dark" : "light");
    drawLines(); // Redraw canvas lines with updated CSS variable colors
    updateDistrictBar();
  });

  // Load saved preference
  const savedTheme = localStorage.getItem("theme");
  if (savedTheme) {
    themeSelect.value = savedTheme;
    if (savedTheme === "system") {
      document.documentElement.removeAttribute("data-theme");

      // Manualy force updates using current system preference
      const isDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
      console.log("Using system theme:", isDark ? "dark" : "light");
    } else {
      document.documentElement.setAttribute("data-theme", savedTheme);
    }

    // Always refresh visuals on page load based on theme
    drawLines();
    updateDistrictBar();
  }

  // On theme selectchange
  themeSelect.addEventListener("change", () => {
    const theme = themeSelect.value;
    localStorage.setItem("theme", theme);
    if (theme === "system") {
      document.documentElement.removeAttribute("data-theme");
    } else {
      document.documentElement.setAttribute("data-theme", theme);
    }

    // Refresh visuals
    drawLines();
    updateDistrictBar();
  });

  // force recheck when system theme changes
  window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', () => {
    if (themeSelect.value === "system") {
      drawLines();
      updateDistrictBar();
    }
  });



  // LOAD RED/BLUE THEME
  const teamSelect = document.getElementById('team-select');

  const savedTeam = localStorage.getItem("team");
  if (savedTeam) {
    teamSelect.value = savedTeam;
    if (savedTeam === "red") {
      // set red team by default
      console.log("loaded saved localstorage color red");
    } else {
      // set blue team by default
      console.log("loaded saved localstorage color blue");
    }
  }
  else {
    console.log("no saved localstorage color");
    console.log("setting default to blue");
    localStorage.setItem("team", "blue");
  }

  // On team select change
  teamSelect.addEventListener("change", () => {
    const teamColor = teamSelect.value;
    localStorage.setItem("team", teamColor);
    console.log("set localStorage team color to " + teamColor);
  });



  // TIMER
  function updateDisplay() {
    const minutes = String(Math.floor(elapsedSeconds / 60)).padStart(2, '0');
    const seconds = String(elapsedSeconds % 60).padStart(2, '0');
    document.getElementById('timelabel').textContent = `${minutes}:${seconds}s`;
  }

  function startTimer() {
    if (timerInterval) return; // prevent multiple intervals
    timerInterval = setInterval(() => {
      elapsedSeconds++;
      updateDisplay();
    }, 1000);
  }

  function stopTimer() {
    clearInterval(timerInterval);
    timerInterval = null;
  }



  // URL PARAM
  window.addEventListener('DOMContentLoaded', () => {
    const urlParams = new URLSearchParams(window.location.search);
    const level = urlParams.get('level');

    if (level !== null) {
      console.log('Level parameter:', level);

      if (level.toUpperCase() in LEVELS) {
        console.log("levels var is the name of one of the levels in levels object");

        selectedLevel = LEVELS[level];

        document.getElementById('puzzle-info').innerText = level;
        document.getElementById('map-number-label').innerText = level.toUpperCase();

        shareNameOfMap = `Challenge Map '${level}'`;
        shareLinkOfMap = "https://ssambender.github.io/gerrymandle/?level=" + level;
      }
      else {
        const groupCount = level[0];
        const groupSize = level[1];
        const gridString = level.slice(2).replace(/X/g, ' ');
        const gridArray = Array.from(gridString);
        const finalArray = [groupCount, groupSize, ...gridArray];

        console.log("Parsed URL level:", finalArray);

        // Set selected level to this parsed one
        selectedLevel = finalArray;
        document.getElementById('puzzle-info').innerText = `Custom Map`;  //  #${dayOfMap}
        document.getElementById('map-number-label').innerText = `CUSTOM MAP`;  //  #${dayOfMap}

        shareNameOfMap = "a Custom Map";
        shareLinkOfMap = "https://ssambender.github.io/gerrymandle/?level=" + level;
      }

      // Remove the param from the URL bar
      history.replaceState(null, '', window.location.pathname);
    } else {
      console.log("No level param. Using today's level.");

      const month = String(today.getMonth() + 1).padStart(2, '0');
      const day = String(today.getDate()).padStart(2, '0');
      const year = String(today.getFullYear()).slice(-2);
      const formatted = `${month}${day}${year}`;

      generateRandomMapFromSeed(formatted).then(level => {
        todaysLevel = level;
        selectedLevel = todaysLevel;
        console.log("loaded level for date/seed: " + formatted);
      });
    }
  });



  // SHOW OTHER LEVELS IN MODAL
  let showingOtherLevels = false;
  document.getElementById('show-other-levels').addEventListener("click", () => {
    if (!showingOtherLevels) {
      document.getElementById('level-buttons').style.display = 'flex';
      document.getElementById('show-other-levels').innerText = 'Hide other premade levels';
    }
    else {
      document.getElementById('level-buttons').style.display = 'none';
      document.getElementById('show-other-levels').innerText = 'Show other premade levels';
    }
    showingOtherLevels = !showingOtherLevels;
  });



  // RESET TITLE
  document.getElementById("title-click").addEventListener("click", () => {
    location.reload();
  });

</script>
</body>
</html>

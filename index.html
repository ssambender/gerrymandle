<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Gerrymandle</title>
  <link rel="icon" href="https://raw.githubusercontent.com/ssambender/gerrymandle/refs/heads/main/g-logo.png">
  <style>
    :root {
      --bg: #ffffff;
      --text: #55698c;

      --gray-highlight: #E8E8E8;
      --red-highlight: #eeb5ae;
      --blue-highlight: #aed1ee;
      --purple-highlight: #ddc6ea;

      --gray-letter: #dadada;
      --red-letter: #e05353;
      --blue-letter: #5988d1;
    }
    /* Override light theme manually */
    html[data-theme="light"] {
      --bg: #ffffff;
      --text: #55698c;
      --gray-highlight: #E8E8E8;
      --red-highlight: #eeb5ae;
      --blue-highlight: #aed1ee;
      --purple-highlight: #ddc6ea;
      --gray-letter: #dadada;
      --red-letter: #e05353;
      --blue-letter: #5988d1;
    }

    /* Override dark theme manually */
    html[data-theme="dark"] {
      --bg: #242f3b;
      --text: #ffffff;
      --gray-highlight: #424f5e;
      --red-highlight: #803026;
      --blue-highlight: #164c7d;
      --purple-highlight: #5f436f;
      --gray-letter: #6e7a86;
      --red-letter: #e05353;
      --blue-letter: #5988d1;
    }

    /* Fallback for system preference (only used if no manual override) */
    @media (prefers-color-scheme: dark) {
      html:not([data-theme]) {
        --bg: #242f3b;
        --text: #ffffff;
        --gray-highlight: #424f5e;
        --red-highlight: #803026;
        --blue-highlight: #164c7d;
        --purple-highlight: #5f436f;
        --gray-letter: #6e7a86;
        --red-letter: #e05353;
        --blue-letter: #5988d1;
      }
    }

    body {
      font-family: 'Clear Sans', 'Helvetica Neue', 'Franklin Gothic Demi Cond', 'Bahnschrift', Arial, sans-serif;
      background: var(--bg);
      display: flex;
      flex-direction: column;
      /*justify-content: center;*/
      align-items: center;
      margin: 0;
      min-height: 100vh;
    }
    @media (min-width: 1060px) {
      body {
        max-height: 100vh;
      }
    }

    #heading {
      color: var(--text);
      font-weight: normal;
      text-transform: uppercase;
      margin-bottom: 0;
      border-bottom: 1px solid var(--gray-highlight);
      width: 100%;
      text-align: center;

      margin-top: 0;
      display: flex;
      justify-content: center;
      align-items: center;
      line-height: 1;
      padding: 14px 0 8px;
    }

    #theme-select {
      color: var(--text);
      font-weight: bold;
      background: var(--bg);
      outline: none;
      border: solid 2px var(--gray-highlight);
    }

    .popup-modal-container {
      position: absolute;
      width: 100vw;
      height: 100vh;
      background-color: rgba(255, 255, 255, 0.75);
      z-index: 10;
      display: flex;
      justify-content: center;
      align-items: center;
      color: var(--text);
      text-align: center;
    }
    .popup-modal {
      background-color: white;
      padding: 48px;
      border-radius: 36px;
      border: solid 2px var(--gray-highlight);
      color: var(--red-letter);
      cursor: default;
    }
    #share-line {
      text-decoration: underline;
      color: #eeb5ae;
      transition: color .15s;
    }
    #share-line:hover {
      cursor: pointer;
      color: var(--red-letter);
    }

    @media all and (orientation: portrait) {
      #heading {
        font-size: 1.5em;
      }
      #puzzle-info {
        font-size: 1.25em;
      }
    }

    #board-container {
      position: relative;
      width: 460px;
      height: 620px;
      min-height: 620px;
    }

    #board {
      display: grid;
      grid-template-columns: repeat(6, 60px);
      grid-template-rows: repeat(8, 60px);
      gap: 20px;
      position: absolute;
      z-index: 2;
    }

    .tile {
      width: 60px;
      height: 60px;
      border-radius: 50%;
      background: var(--bg);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 28px;
      font-weight: bold;
      color: var(--text);
      /*cursor: pointer;*/
      user-select: none;
      line-height: 1;  /* remove this line if using text not symbols in tiles */
      vertical-align: middle;
    }

    /* Highlight classes */
    .tile.selected {
      background: var(--gray-highlight);
    }
    .tile.selected-red {
      background: var(--red-highlight);
    }
    .tile.selected-blue {
      background: var(--blue-highlight);
    }
    .tile.selected-purple {
      background: var(--purple-highlight);
    }

    .tile-red {
      color: var(--red-letter);
    }
    .tile-blue {
      color: var(--blue-letter);
    }
    .tile-gray {
      color: var(--gray-letter);
    }

    #line-canvas {
      position: absolute;
      top: 0;
      left: 0;
      z-index: 1;
      pointer-events: none;
    }

    #level-buttons {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      margin-top: 12px;
      padding: 10px;
      justify-content: center;
      align-items: center;
    }
    #level-buttons button {
      background: var(--bg);
      outline: none;
      border: solid 2px var(--gray-highlight);
      color: var(--gray-highlight);
      cursor: pointer;
    }
    #level-buttons button:hover {
      color: var(--text);
      border: solid 2px var(--text);
    }

    #madebysam {
      color: var(--text);
      cursor: pointer;
      margin-top: 36px;
      padding-bottom: 12px;
      text-align: center;
      font-size: 0.9rem;
      text-decoration: none;
    }
    #madebysam:hover {
      text-decoration: underline;
    }

    @keyframes pop {
      0%   { transform: scale(1); }
      30%  { transform: scale(1.1); }
      60%  { transform: scale(0.95); }
      100% { transform: scale(1); }
    }

    .tile.pop {
      animation: pop 250ms ease-out;
    }
    .tile.fade-text {
      transition: color 1s ease;
      color: transparent !important;
    }

    .district-segment {
      height: 100%;
      transition: width 0.3s ease;
    }

    @media (max-width: 619px) {
      #board-container {
        width: 360px;
        height: 484px;
        min-height: 484px;
      }

      #board {
        grid-template-columns: repeat(6, 40px);
        grid-template-rows: repeat(8, 40px);
        gap: 14px;
      }

      .tile {
        width: 40px;
        height: 40px;
        font-size: 20px;
      }

      #line-canvas {
        width: 360px !important;
        height: 484px !important;
      }
    }

    @media (max-width: 460px) {
      #heading {
        font-size: 1.1em;
        box-sizing: border-box;
      }
    }
  </style>
</head>
<body>

<div id="finish-modal-container" class="popup-modal-container" style="display: none;">
  <div id="finish-modal" class="popup-modal">
    <div id="win-message" style="font-weight: bold; font-size: 2em; text-transform: uppercase;">Well Done!</div>
    <div style="font-weight: normal; font-size: 1em; margin: 16px 0; color: var(--blue-highlight);">FINISHED MAP #<span id="map-number-label">324</span> IN <span id="time-spent-label">02:12s</span></div>
    <div id="share-line">Share your time with friends.</div>
  </div>
</div>

<h1 id="heading"><span style="color: var(--red-letter)">‚òÖ‚òÖ‚òÖ</span> Gerrymandle <span style="color: var(--blue-letter)">‚òÖ‚òÖ‚òÖ</span></h1>

<h2 id="puzzle-info" style="margin-bottom: 0; color: var(--text);">? districts of ?</h2>
<h3 id="puzzle-subinfo" style="margin-top: 0; margin-bottom: 0; font-weight: normal; color: var(--text);"><b style="color: var(--blue-letter)">17</b> - <b style="color: var(--red-letter)">13</b>. Help red win!</h3>
<div id="puzzle-districtbar" style="margin-top: 10px; width: 260px; height: 20px; background: var(--gray-highlight); display: flex; border-radius: 10px; overflow: hidden; margin-bottom: 10px;"></div>
<div id="board-container">
  <canvas id="line-canvas" width="460" height="620"></canvas>
  <div id="board"></div>
</div>

<div id="level-buttons"></div>

<div id="theme-toggle" style="position: absolute; top: 12px; right: 24px;">
  <label for="theme-select" style="color: var(--text);">Theme:</label>
  <select id="theme-select">
    <option value="system">System</option>
    <option value="light">Light</option>
    <option value="dark">Dark</option>
  </select>
</div>

<a id="madebysam" href="https://sambender.net">
  Made with ‚ù§Ô∏è by Sam Bender
</a>

<script>
  const boardCols = 6;
  const boardRows = 8;

  const levels = {
    LVL00: ["16", "3",
      "B", "B", "B", "B", "B", "B",
      "R", "R", "B", "R", "R", "B",
      "R", "R", "B", "R", "R", "B",
      "B", "B", "B", "B", "B", "B",
      "R", "R", "B", "R", "R", "B",
      "R", "R", "B", "R", "R", "B",
      "R", "R", "B", "R", "R", "B",
      "B", "B", "B", "B", "B", "B"
    ],
    LVL01: ["5", "3",
      " ", " ", " ", " ", " ", " ",
      " ", " ", " ", "O", "R", "R",
      "R", "B", "B", "B", "O", " ",
      " ", "B", "B", " ", "O", " ",
      " ", "R", "O", "B", " ", "B",
      " ", "R", "O", "B", " ", " ",
      " ", " ", "R", "B", "O", " ",
      " ", " ", " ", " ", " ", " "
    ],
    LVL02: ["5", "3",
      " ", " ", " ", " ", " ", " ",
      " ", " ", "B", " ", "B", "B",
      " ", "R", "R", "O", "O", " ",
      " ", "R", "B", "B", " ", " ",
      " ", "R", "R", " ", " ", " ",
      "B", "R", "B", " ", " ", " ",
      " ", "B", "B", " ", " ", " ",
      " ", " ", " ", " ", " ", " "
    ],
    LVL03: ["7", "3",
      " ", " ", " ", " ", " ", " ",
      " ", " ", "B", "B", "B", "B",
      " ", " ", "B", "B", "B", " ",
      " ", "B", "B", "R", "O", "R",
      "R", "R", "R", "B", "B", "R",
      "R", "R", "B", "O", "R", " ",
      " ", "O", "O", " ", " ", " ",
      " ", " ", " ", " ", " ", " "
    ],
    LVL04: ["5", "5",
      " ", "R", "B", "O", " ", " ",
      "R", "B", "R", "B", "O", " ",
      " ", "B", "B", "O", "B", "O",
      " ", "B", "O", "B", "O", "B",
      "B", "B", "B", "R", "B", " ",
      " ", " ", "B", "R", "R", " ",
      " ", "B", "R", "R", "O", "R",
      " ", " ", "R", "O", " ", " "
    ],
    LVL05: ["5", "3",
      " ", " ", " ", " ", " ", " ",
      " ", " ", " ", " ", " ", " ",
      "R", "R", "B", "O", " ", " ",
      " ", "B", "B", "B", "B", "R",
      "R", "O", "B", "B", "R", "B",
      "B", " ", "O", "R", " ", " ",
      " ", " ", " ", " ", " ", " ",
      " ", " ", " ", " ", " ", " "
    ],
    LVL06: ["5", "4",
      " ", " ", " ", " ", " ", " ",
      " ", "B", " ", "B", "R", " ",
      "B", " ", "O", "O", "R", "R",
      " ", "O", "B", "B", " ", "O",
      " ", "B", "R", "B", "B", "O",
      "R", "O", "R", "R", "B", "R",
      " ", " ", "B", "R", "B", " ",
      " ", " ", " ", " ", " ", " "
    ],
    LVL07: ["5", "3",
      " ", " ", " ", " ", " ", " ",
      " ", " ", " ", "O", "B", "B",
      "O", "O", "O", "B", "O", "B",
      "B", "R", "R", "B", "O", "O",
      "R", " ", "B", " ", "O", "R",
      " ", " ", " ", "B", "R", "O",
      " ", " ", " ", " ", "R", "B",
      " ", " ", " ", " ", " ", " "
    ],
    LVL08: ["3", "8",
      " ", "R", "B", "B", "B", " ",
      " ", "B", " ", " ", "R", " ",
      " ", "R", " ", " ", "B", " ",
      " ", "B", "R", "B", "B", " ",
      " ", "R", "R", "B", "B", " ",
      " ", "B", " ", " ", "R", " ",
      " ", "B", " ", " ", "R", " ",
      " ", "R", "R", "B", "R", " "
    ],
    LVL09: ["5", "5",
      " ", " ", " ", " ", "B", "B",
      " ", " ", " ", "R", "B", "O",
      "B", "R", "R", "B", "B", " ",
      " ", " ", "O", " ", "B", "R",
      "R", "B", "B", " ", "B", "B",
      " ", " ", "B", " ", "R", "R",
      " ", " ", " ", "R", "R", "B",
      " ", " ", " ", "R", "B", "B"
    ],
    LVL10: ["5", "6",
      " ", "R", " ", "B", "B", " ",
      "R", "B", "B", "R", "B", "R",
      "B", "R", "B", "B", "R", " ",
      " ", "B", "R", "B", "O", "B",
      "R", "O", "R", "B", "B", " ",
      "R", "B", "R", " ", "R", "B",
      " ", "R", "B", "B", "O", " ",
      " ", " ", " ", " ", " ", " "
    ]
  };

  const styleVars = getComputedStyle(document.documentElement);

  function generateLevelButtons() {
    const container = document.getElementById("level-buttons");
    for (const key in levels) {
      const btn = document.createElement("button");
      btn.innerText = key;
      btn.onclick = () => loadLevel(key);
      container.appendChild(btn);
    }
  }
  generateLevelButtons();

  let currentDistrictCount = 0;
  let currentVoteCount = 0;

  let levelData = [];
  let finalizedDistricts = [];

  // CHARACTER SYMBOLS TO DISPLAY
  /*
  ‚òÖ‚ú©‚ú∞
  ‚ú™
  ‚ú¶‚úß
  ‚úØ
  R üü•
  B üü¶
  W ‚¨ú
  */
  function getDisplayCharacter(char) {
    switch (char) {
      case "R": return "‚òÖ";
      case "B": return "‚ú™";
      case "O": return "‚ú©";
      default: return " ";
    }
  }

  function loadLevel(levelName) {
    if (!levels[levelName]) return;

    board.style.pointerEvents = "auto";

    const data = levels[levelName];

    currentDistrictCount = parseInt(data[0]);
    currentVoteCount = parseInt(data[1]);

    // Update levelData
    levelData.length = 0;
    levelData.push(...data);

    // Clear previous state
    finalizedDistricts = [];
    board.innerHTML = "";
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // Rebuild board
    let index = 2; // skip the first two (district x vote var counts)
    for (let row = 0; row < boardRows; row++) {
      for (let col = 0; col < boardCols; col++) {
        const tile = document.createElement("div");
        tile.classList.add("tile");

        const letter = data[index] || "";
        //tile.dataset.value = letter;
        tile.dataset.value = letter; // store actual value for logic
        tile.innerText = getDisplayCharacter(letter); // show visual representation
        if (letter === "B") {
          //tile.style.color = styleVars.getPropertyValue('--blue-letter').trim();
          tile.classList.add("tile-blue");
          tile.style.cursor = "pointer";
        }
        if (letter === "R") {
          //tile.style.color = styleVars.getPropertyValue('--red-letter').trim();
          tile.classList.add("tile-red");
          tile.style.cursor = "pointer";
        }
        if (letter === "O") {
          //tile.style.color = styleVars.getPropertyValue('--gray-letter').trim();
          tile.classList.add("tile-gray");
          tile.style.cursor = "pointer";
        }

        tile.dataset.row = row;
        tile.dataset.col = col;

        tile.addEventListener("click", () => {
          if (isTileFinalized(tile)) {
            removeDistrictContainingTile(tile);
            drawLines();
          }
        });

        board.appendChild(tile);
        index++;
      }
    }

    setInfo();
    updateVoteTotals();
    updateDistrictBar();
    resizeCanvas();
  }

  const board = document.getElementById("board");
  const canvas = document.getElementById("line-canvas");
  const ctx = canvas.getContext("2d");
  let isMouseDown = false;
  let path = [];

  function resizeCanvas() {
    const container = document.getElementById("board-container");
    canvas.width = container.offsetWidth;
    canvas.height = container.offsetHeight;
    drawLines(); // redraw after resize
  }
  resizeCanvas();

  function setInfo() {
    const today = new Date();
    const mm = today.getMonth() + 1;
    const dd = today.getDate();
    const yy = String(today.getFullYear()).slice(-2);
    const formattedDate = `${mm}/${dd}/${yy}`;

    //document.getElementById('puzzle-info').innerText = `${formattedDate} - ${currentDistrictCount} districts of ${currentVoteCount}`;
    document.getElementById('puzzle-info').innerText = `${currentDistrictCount} districts of ${currentVoteCount}`;  // no date
  }
  function updateVoteTotals() {
    const rTotal = levelData.filter(cell => cell === "R").length;
    const bTotal = levelData.filter(cell => cell === "B").length;

    const subInfo = document.getElementById('puzzle-subinfo');
    subInfo.innerHTML = `<b style="color: #5988d1">${bTotal}</b> - <b style="color: #e05353">${rTotal}</b>. Help red win!`;
  }
  setInfo();
  updateVoteTotals();

  function updateDistrictBar() {
    const bar = document.getElementById("puzzle-districtbar");

    const styleVars = getComputedStyle(document.documentElement);
    const total = currentDistrictCount;
    let red = 0, blue = 0, purple = 0;

    finalizedDistricts.forEach(d => {
      if (d.colorClass === "selected-red") red++;
      else if (d.colorClass === "selected-blue") blue++;
      else if (d.colorClass === "selected-purple") purple++;
    });

    const remaining = total - red - blue - purple;

    const segments = [
      { key: "red", count: red, color: styleVars.getPropertyValue('--red-highlight').trim() },
      { key: "blue", count: blue, color: styleVars.getPropertyValue('--blue-highlight').trim() },
      { key: "purple", count: purple, color: styleVars.getPropertyValue('--purple-highlight').trim() },
      { key: "gray", count: remaining, color: styleVars.getPropertyValue('--gray-highlight').trim() }
    ];

    // Update or create segments
    segments.forEach((seg, i) => {
      let segment = bar.children[i];
      const desiredWidth = `${(seg.count / total) * 100}%`;

      if (!segment) {
        // New segment
        segment = document.createElement("div");
        segment.className = "district-segment";
        segment.style.background = seg.color;
        segment.style.width = "0";
        bar.appendChild(segment);
        requestAnimationFrame(() => {
          segment.style.width = desiredWidth;
        });
      } else {
        // Existing segment: update color & width only if changed
        if (segment.style.background !== seg.color) {
          segment.style.background = seg.color;
        }
        if (segment.style.width !== desiredWidth) {
          segment.style.width = desiredWidth;
        }
      }
    });

    // Remove extra segments if any
    while (bar.children.length > segments.length) {
      bar.removeChild(bar.lastChild);
    }
  }


  function getTileCenter(tile) {
    const rect = tile.getBoundingClientRect();
    const parentRect = board.getBoundingClientRect();
    return {
      x: rect.left - parentRect.left + rect.width / 2,
      y: rect.top - parentRect.top + rect.height / 2
    };
  }

  // Draw lines connecting tiles for given path with specified color and line width
  function drawPathLines(pathTiles, color, lineWidth = 16) {
    if (pathTiles.length < 2) return;
    ctx.strokeStyle = color;
    ctx.lineWidth = lineWidth;
    ctx.lineCap = "round";
    ctx.beginPath();
    const start = getTileCenter(pathTiles[0]);
    ctx.moveTo(start.x, start.y);
    for (let i = 1; i < pathTiles.length; i++) {
      const point = getTileCenter(pathTiles[i]);
      ctx.lineTo(point.x, point.y);
    }
    ctx.stroke();
  }

  function updateCurrentPathColors() {
    if (path.length === 0) return;

    const votes = path.map(t => t.dataset.value);
    const rCount = votes.filter(v => v === "R").length;
    const bCount = votes.filter(v => v === "B").length;

    // Remove all color classes first
    path.forEach(t => {
      t.classList.remove("selected", "selected-red", "selected-blue", "selected-purple");
    });

    const voteCount = path.filter(t => {
      const val = t.dataset.value.trim();
      return val === "R" || val === "B";
    }).length;

    if (voteCount >= currentVoteCount) {
      // Apply matching color class
      if (rCount > bCount) {
        path.forEach(t => t.classList.add("selected-red"));
      } else if (bCount > rCount) {
        path.forEach(t => t.classList.add("selected-blue"));
      } else {
        path.forEach(t => t.classList.add("selected-purple"));
      }
    } else {
      // Not full length apply default selected bg
      path.forEach(t => t.classList.add("selected"));
    }
  }

  // draws all finalized districts lines plus current drawing path line
  function drawLines() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // Draw finalized districts lines first
    finalizedDistricts.forEach(district => {
      const color = getStrokeColorForClass(district.colorClass);
      drawPathLines(district.tiles, color);
    });

    // Draw current path line if any
    if (path.length < 2) return;

    const voteCount = path.filter(t => {
      const val = t.dataset.value.trim();
      return val === "R" || val === "B";
    }).length;

    if (voteCount >= currentVoteCount) {
      const strokeColor = finalizePathColor();
      drawPathLines(path, strokeColor);
    } else {
      const gray = styleVars.getPropertyValue('--gray-highlight').trim();
      drawPathLines(path, gray);
    }

  }

  // get stroke color string for given tile class
  function getStrokeColorForClass(colorClass) {
    switch (colorClass) {
      case "selected-red": return styleVars.getPropertyValue('--red-highlight').trim();
      case "selected-blue": return styleVars.getPropertyValue('--blue-highlight').trim();
      case "selected-purple": return styleVars.getPropertyValue('--purple-highlight').trim();
      default: return styleVars.getPropertyValue('--gray-highlight').trim();
    }
  }

  function areAdjacent(tile1, tile2) {
    const r1 = +tile1.dataset.row;
    const c1 = +tile1.dataset.col;
    const r2 = +tile2.dataset.row;
    const c2 = +tile2.dataset.col;

    const rowDiff = r2 - r1;
    const colDiff = c2 - c1;

    const absRow = Math.abs(rowDiff);
    const absCol = Math.abs(colDiff);

    if (absRow > 1 || absCol > 1 || (absRow === 0 && absCol === 0)) return false;

    // Diagonal move
    if (absRow === 1 && absCol === 1) {
      const midTileA = document.querySelector(`[data-row="${r1}"][data-col="${c2}"]`);
      const midTileB = document.querySelector(`[data-row="${r2}"][data-col="${c1}"]`);

      // Check if either of the mid-tiles are connected by a finalized district
      for (const district of finalizedDistricts) {
        if (
                midTileA && midTileB &&
                district.tiles.includes(midTileA) &&
                district.tiles.includes(midTileB)
        ) {
          // They're both in a district ‚Äî check if they're directly connected
          const idxA = district.tiles.indexOf(midTileA);
          const idxB = district.tiles.indexOf(midTileB);
          if (Math.abs(idxA - idxB) === 1) {
            return false; // A connector exists ‚Äî block diagonal
          }
        }
      }
    }

    return true;
  }


  function clearPath() {
    path.forEach(t => {
      if (!isTileFinalized(t)) {
        t.classList.remove("selected", "selected-red", "selected-blue", "selected-purple");
      }
    });
    path = [];
    drawLines();
  }

  function isTileFinalized(tile) {
    return finalizedDistricts.some(district => district.tiles.includes(tile));
  }

  function removeDistrictContainingTile(tile) {
    for (let i = 0; i < finalizedDistricts.length; i++) {
      const district = finalizedDistricts[i];
      if (district.tiles.includes(tile)) {
        // Log what colord district is removed
        let colorName = "purple";
        if (district.colorClass === "selected-red") colorName = "red";
        else if (district.colorClass === "selected-blue") colorName = "blue";
        console.log(`${colorName} district removed`);

        district.tiles.forEach(t => {
          t.classList.remove("selected-red", "selected-blue", "selected-purple");
        });
        finalizedDistricts.splice(i, 1);

        // Log updated totals
        let redCount = 0, blueCount = 0, purpleCount = 0;
        finalizedDistricts.forEach(d => {
          if (d.colorClass === "selected-red") redCount++;
          else if (d.colorClass === "selected-blue") blueCount++;
          else if (d.colorClass === "selected-purple") purpleCount++;
        });
        console.log(`total red: ${redCount}, total blue: ${blueCount}, total purple: ${purpleCount}`);

        updateDistrictBar();

        break;
      }
    }
  }

  // SHARE DATA AND SHARE LINK
  let dayOfMap = 324;
  let timeSpentSeconds = 121;
  const shareData = {
    title: 'Gerrymandle #' + dayOfMap,
    text: `üî∏I beat map #${dayOfMap}` + ` in ${timeSpentSeconds}s. üó∫Ô∏è \nüîπThink you can solve it faster?\nhttps://ssambender.github.io/gerrymandle/`,
    //url: 'https://ssambender.github.io/gerrymandle/'
  }
  let sharelink = document.getElementById('share-line');
  sharelink.addEventListener('click', async () => {
    event.preventDefault();
    try {
      await navigator.share(shareData)
      console.log('shared successfully')
    } catch (err) {
      console.log('error' + err)
    }
  }, false);

  // EVENT LISTENERS
  board.addEventListener("mousedown", (e) => {
    if (!e.target.classList.contains("tile")) return;
    if (isTileFinalized(e.target)) return;
    if (e.target.dataset.value.trim() === "") return;  //prevents selecting blank spaces

    clearPath();
    isMouseDown = true;

    path.push(e.target);
    updateCurrentPathColors();
    drawLines();

    e.target.classList.add("pop");
    e.target.addEventListener("animationend", () => {
      e.target.classList.remove("pop");
    }, { once: true });
  });

  board.addEventListener("mouseover", (e) => {
    if (!isMouseDown || !e.target.classList.contains("tile")) return;
    if (isTileFinalized(e.target)) return;

    const currentTile = e.target;
    if (currentTile.dataset.value.trim() === "") return;  //prevents selecting blank spaces

    const last = path[path.length - 1];
    const secondLast = path[path.length - 2];

    // Allow retreating
    if (secondLast === currentTile) {
      const removed = path.pop();
      removed.classList.remove("selected", "selected-red", "selected-blue", "selected-purple");
      updateCurrentPathColors();
      drawLines();
      return;
    }

    const voteCount = path.filter(t => {
      const val = t.dataset.value.trim();
      return val === "R" || val === "B";
    }).length;

    const atLimit = voteCount >= currentVoteCount;

    if (atLimit) return;

    if (!path.includes(currentTile) && areAdjacent(last, currentTile)) {
      path.push(currentTile);
      updateCurrentPathColors();
      drawLines();

      currentTile.classList.add("pop");
      currentTile.addEventListener("animationend", () => {
        currentTile.classList.remove("pop");
      }, { once: true });
    }
  });

  window.addEventListener("mouseup", () => {
    if (path.length > 0) {
      const word = path.map(t => t.dataset.value).join("");
      // console.log("Selected word:", word);

      const voteCount = path.filter(t => {
        const val = t.dataset.value.trim();
        return val === "R" || val === "B";
      }).length;

      if (voteCount === currentVoteCount) {
        // Finalize district
        const colorClass = getFinalColorClass();

        finalizedDistricts.push({
          tiles: [...path],
          colorClass
        });

        // remove temp selected class and apply final color class only
        path.forEach(t => {
          t.classList.remove("selected");
          t.classList.add(colorClass);
        });

        // log district color drawn
        let colorName = "purple";
        if (colorClass === "selected-red") colorName = "red";
        else if (colorClass === "selected-blue") colorName = "blue";
        console.log(`${colorName} district drawn`);

        // Count totals
        let redCount = 0, blueCount = 0, purpleCount = 0;
        finalizedDistricts.forEach(district => {
          if (district.colorClass === "selected-red") redCount++;
          else if (district.colorClass === "selected-blue") blueCount++;
          else if (district.colorClass === "selected-purple") purpleCount++;
        });
        console.log(`total red: ${redCount}, total blue: ${blueCount}, total purple: ${purpleCount}`);

        updateDistrictBar();

        if (finalizedDistricts.length === currentDistrictCount) {
          console.log("all districts drawn");
          if (redCount > blueCount) {
            console.log("LEVEL WIN!");

            board.style.pointerEvents = "none";  // stop board edits after win
            //board.style.pointerEvents = "auto";  // to reenable events on board reset or something

            document.querySelectorAll('.tile').forEach(tile => {
              const row = parseInt(tile.dataset.row);
              const col = parseInt(tile.dataset.col);
              const delay = (row * boardCols + col) * 15;
              setTimeout(() => {
                tile.classList.add('fade-text');
              }, delay);
            });
          }
          else {
            console.log("NOT QUITE! LEVEL LOSE!");
            // todo - show up "reset?" button
          }
        }

        path = [];
        drawLines();
      } else {
        clearPath();
      }
    }
    isMouseDown = false;
  });


  window.addEventListener("mouseleave", () => {
    isMouseDown = false;
  });

  function getFinalColorClass() {
    const votes = path
            .map(t => t.dataset.value)
            .filter(v => v !== "O");
    const rCount = votes.filter(v => v === "R").length;
    const bCount = votes.filter(v => v === "B").length;

    if (rCount > bCount) return "selected-red";
    else if (bCount > rCount) return "selected-blue";
    else return "selected-purple";
  }

  function finalizePathColor() {
    const votes = path
            .map(t => t.dataset.value)
            .filter(v => v !== "O");
    const rCount = votes.filter(v => v === "R").length;
    const bCount = votes.filter(v => v === "B").length;

    if (rCount > bCount) return styleVars.getPropertyValue('--red-highlight').trim();
    else if (bCount > rCount) return styleVars.getPropertyValue('--blue-highlight').trim();
    else return styleVars.getPropertyValue('--purple-highlight').trim();
  }

  window.addEventListener("resize", () => {
    resizeCanvas();
    drawLines();
  });

  window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', (e) => {
    console.log("Color scheme changed:", e.matches ? "dark" : "light");
    drawLines(); // Redraw canvas lines with updated CSS variable colors
    updateDistrictBar();
  });



  const themeSelect = document.getElementById("theme-select");

  // Load saved preference
  const savedTheme = localStorage.getItem("theme");
  if (savedTheme) {
    themeSelect.value = savedTheme;
    if (savedTheme === "system") {
      document.documentElement.removeAttribute("data-theme");

      // Manualy force updates using current system preference
      const isDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
      console.log("Using system theme:", isDark ? "dark" : "light");
    } else {
      document.documentElement.setAttribute("data-theme", savedTheme);
    }

    // Always refresh visuals on page load based on theme
    drawLines();
    updateDistrictBar();
  }

  // On theme selectchange
  themeSelect.addEventListener("change", () => {
    const theme = themeSelect.value;
    localStorage.setItem("theme", theme);
    if (theme === "system") {
      document.documentElement.removeAttribute("data-theme");
    } else {
      document.documentElement.setAttribute("data-theme", theme);
    }

    // Refresh visuals
    drawLines();
    updateDistrictBar();
  });

  // force recheck when system theme changes
  window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', () => {
    if (themeSelect.value === "system") {
      drawLines();
      updateDistrictBar();
    }
  });




  // start with test level loaded by default
  loadLevel('LVL01');
</script>
</body>
</html>
